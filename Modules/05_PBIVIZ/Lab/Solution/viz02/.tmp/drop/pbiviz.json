{"visual":{"name":"viz02","displayName":"viz02","guid":"PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6_DEBUG","visualClassName":"Visual","version":"1.0.0","description":"","supportUrl":"","gitHubUrl":""},"apiVersion":"1.5.0","author":{"name":"","email":""},"assets":{"icon":"assets/icon.png"},"externalJS":[],"style":"style/visual.less","capabilities":{"dataRoles":[{"displayName":"Category Data","name":"category","kind":"Grouping"},{"displayName":"Measure Data","name":"measure","kind":"Measure"}],"dataViewMappings":[{"categorical":{"categories":{"for":{"in":"category"},"dataReductionAlgorithm":{"top":{}}},"values":{"select":[{"bind":{"to":"measure"}}]}}}]},"content":{"js":"var powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var visual;\r\n        (function (visual) {\r\n            var PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6;\r\n            (function (PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6) {\r\n                var Visual = (function () {\r\n                    function Visual(options) {\r\n                        this.container = $(options.element);\r\n                    }\r\n                    Visual.prototype.update = function (options) {\r\n                        var table = $(\"<table>\", { \"id\": \"myTable\" })\r\n                            .append($(\"<tr>\")\r\n                            .append($(\"<td>\").text(\"Width\"))\r\n                            .append($(\"<td>\").text(options.viewport.width.toFixed(0))))\r\n                            .append($(\"<tr>\")\r\n                            .append($(\"<td>\").text(\"Height\"))\r\n                            .append($(\"<td>\").text(options.viewport.height.toFixed(0))));\r\n                        var scaledFontSizeWidth = Math.round(options.viewport.width / 7);\r\n                        var scaledFontSizeHeight = Math.round(options.viewport.height / 5);\r\n                        var scaledFontSize = Math.min.apply(Math, [scaledFontSizeWidth, scaledFontSizeHeight]);\r\n                        var scaledFontSizeCss = scaledFontSize + \"px\";\r\n                        $(\"td\", table).css({\r\n                            \"font-size\": scaledFontSizeCss\r\n                        });\r\n                        this.container.empty().append(table);\r\n                    };\r\n                    return Visual;\r\n                }());\r\n                PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6.Visual = Visual;\r\n            })(PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6 = visual.PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6 || (visual.PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6 = {}));\r\n        })(visual = extensibility.visual || (extensibility.visual = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*!\r\n * jQuery JavaScript Library v3.1.1\r\n * https://jquery.com/\r\n *\r\n * Includes Sizzle.js\r\n * https://sizzlejs.com/\r\n *\r\n * Copyright jQuery Foundation and other contributors\r\n * Released under the MIT license\r\n * https://jquery.org/license\r\n *\r\n * Date: 2016-09-22T22:30Z\r\n */\r\n(function (global, factory) {\r\n    \"use strict\";\r\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        // For CommonJS and CommonJS-like environments where a proper `window`\r\n        // is present, execute the factory and get jQuery.\r\n        // For environments that do not have a `window` with a `document`\r\n        // (such as Node.js), expose a factory as module.exports.\r\n        // This accentuates the need for the creation of a real `window`.\r\n        // e.g. var jQuery = require(\"jquery\")(window);\r\n        // See ticket #14549 for more info.\r\n        module.exports = global.document ?\r\n            factory(global, true) :\r\n            function (w) {\r\n                if (!w.document) {\r\n                    throw new Error(\"jQuery requires a window with a document\");\r\n                }\r\n                return factory(w);\r\n            };\r\n    }\r\n    else {\r\n        factory(global);\r\n    }\r\n    // Pass this if window is not defined yet\r\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\r\n    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\r\n    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\r\n    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\r\n    // enough that all such attempts are guarded in a try block.\r\n    \"use strict\";\r\n    var arr = [];\r\n    var document = window.document;\r\n    var getProto = Object.getPrototypeOf;\r\n    var slice = arr.slice;\r\n    var concat = arr.concat;\r\n    var push = arr.push;\r\n    var indexOf = arr.indexOf;\r\n    var class2type = {};\r\n    var toString = class2type.toString;\r\n    var hasOwn = class2type.hasOwnProperty;\r\n    var fnToString = hasOwn.toString;\r\n    var ObjectFunctionString = fnToString.call(Object);\r\n    var support = {};\r\n    function DOMEval(code, doc) {\r\n        doc = doc || document;\r\n        var script = doc.createElement(\"script\");\r\n        script.text = code;\r\n        doc.head.appendChild(script).parentNode.removeChild(script);\r\n    }\r\n    /* global Symbol */\r\n    // Defining this global in .eslintrc.json would create a danger of using the global\r\n    // unguarded in another place, it seems safer to define global only for this module\r\n    var version = \"3.1.1\", \r\n    // Define a local copy of jQuery\r\n    jQuery = function (selector, context) {\r\n        // The jQuery object is actually just the init constructor 'enhanced'\r\n        // Need init if jQuery is called (just allow error to be thrown if not included)\r\n        return new jQuery.fn.init(selector, context);\r\n    }, \r\n    // Support: Android <=4.0 only\r\n    // Make sure we trim BOM and NBSP\r\n    rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \r\n    // Matches dashed string for camelizing\r\n    rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, \r\n    // Used by jQuery.camelCase as callback to replace()\r\n    fcamelCase = function (all, letter) {\r\n        return letter.toUpperCase();\r\n    };\r\n    jQuery.fn = jQuery.prototype = {\r\n        // The current version of jQuery being used\r\n        jquery: version,\r\n        constructor: jQuery,\r\n        // The default length of a jQuery object is 0\r\n        length: 0,\r\n        toArray: function () {\r\n            return slice.call(this);\r\n        },\r\n        // Get the Nth element in the matched element set OR\r\n        // Get the whole matched element set as a clean array\r\n        get: function (num) {\r\n            // Return all the elements in a clean array\r\n            if (num == null) {\r\n                return slice.call(this);\r\n            }\r\n            // Return just the one element from the set\r\n            return num < 0 ? this[num + this.length] : this[num];\r\n        },\r\n        // Take an array of elements and push it onto the stack\r\n        // (returning the new matched element set)\r\n        pushStack: function (elems) {\r\n            // Build a new jQuery matched element set\r\n            var ret = jQuery.merge(this.constructor(), elems);\r\n            // Add the old object onto the stack (as a reference)\r\n            ret.prevObject = this;\r\n            // Return the newly-formed element set\r\n            return ret;\r\n        },\r\n        // Execute a callback for every element in the matched set.\r\n        each: function (callback) {\r\n            return jQuery.each(this, callback);\r\n        },\r\n        map: function (callback) {\r\n            return this.pushStack(jQuery.map(this, function (elem, i) {\r\n                return callback.call(elem, i, elem);\r\n            }));\r\n        },\r\n        slice: function () {\r\n            return this.pushStack(slice.apply(this, arguments));\r\n        },\r\n        first: function () {\r\n            return this.eq(0);\r\n        },\r\n        last: function () {\r\n            return this.eq(-1);\r\n        },\r\n        eq: function (i) {\r\n            var len = this.length, j = +i + (i < 0 ? len : 0);\r\n            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\r\n        },\r\n        end: function () {\r\n            return this.prevObject || this.constructor();\r\n        },\r\n        // For internal use only.\r\n        // Behaves like an Array's method, not like a jQuery method.\r\n        push: push,\r\n        sort: arr.sort,\r\n        splice: arr.splice\r\n    };\r\n    jQuery.extend = jQuery.fn.extend = function () {\r\n        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;\r\n        // Handle a deep copy situation\r\n        if (typeof target === \"boolean\") {\r\n            deep = target;\r\n            // Skip the boolean and the target\r\n            target = arguments[i] || {};\r\n            i++;\r\n        }\r\n        // Handle case when target is a string or something (possible in deep copy)\r\n        if (typeof target !== \"object\" && !jQuery.isFunction(target)) {\r\n            target = {};\r\n        }\r\n        // Extend jQuery itself if only one argument is passed\r\n        if (i === length) {\r\n            target = this;\r\n            i--;\r\n        }\r\n        for (; i < length; i++) {\r\n            // Only deal with non-null/undefined values\r\n            if ((options = arguments[i]) != null) {\r\n                // Extend the base object\r\n                for (name in options) {\r\n                    src = target[name];\r\n                    copy = options[name];\r\n                    // Prevent never-ending loop\r\n                    if (target === copy) {\r\n                        continue;\r\n                    }\r\n                    // Recurse if we're merging plain objects or arrays\r\n                    if (deep && copy && (jQuery.isPlainObject(copy) ||\r\n                        (copyIsArray = jQuery.isArray(copy)))) {\r\n                        if (copyIsArray) {\r\n                            copyIsArray = false;\r\n                            clone = src && jQuery.isArray(src) ? src : [];\r\n                        }\r\n                        else {\r\n                            clone = src && jQuery.isPlainObject(src) ? src : {};\r\n                        }\r\n                        // Never move original objects, clone them\r\n                        target[name] = jQuery.extend(deep, clone, copy);\r\n                    }\r\n                    else if (copy !== undefined) {\r\n                        target[name] = copy;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Return the modified object\r\n        return target;\r\n    };\r\n    jQuery.extend({\r\n        // Unique for each copy of jQuery on the page\r\n        expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\r\n        // Assume jQuery is ready without the ready module\r\n        isReady: true,\r\n        error: function (msg) {\r\n            throw new Error(msg);\r\n        },\r\n        noop: function () { },\r\n        isFunction: function (obj) {\r\n            return jQuery.type(obj) === \"function\";\r\n        },\r\n        isArray: Array.isArray,\r\n        isWindow: function (obj) {\r\n            return obj != null && obj === obj.window;\r\n        },\r\n        isNumeric: function (obj) {\r\n            // As of jQuery 3.0, isNumeric is limited to\r\n            // strings and numbers (primitives or objects)\r\n            // that can be coerced to finite numbers (gh-2662)\r\n            var type = jQuery.type(obj);\r\n            return (type === \"number\" || type === \"string\") &&\r\n                // parseFloat NaNs numeric-cast false positives (\"\")\r\n                // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\r\n                // subtraction forces infinities to NaN\r\n                !isNaN(obj - parseFloat(obj));\r\n        },\r\n        isPlainObject: function (obj) {\r\n            var proto, Ctor;\r\n            // Detect obvious negatives\r\n            // Use toString instead of jQuery.type to catch host objects\r\n            if (!obj || toString.call(obj) !== \"[object Object]\") {\r\n                return false;\r\n            }\r\n            proto = getProto(obj);\r\n            // Objects with no prototype (e.g., `Object.create( null )`) are plain\r\n            if (!proto) {\r\n                return true;\r\n            }\r\n            // Objects with prototype are plain iff they were constructed by a global Object function\r\n            Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\r\n            return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\r\n        },\r\n        isEmptyObject: function (obj) {\r\n            /* eslint-disable no-unused-vars */\r\n            // See https://github.com/eslint/eslint/issues/6125\r\n            var name;\r\n            for (name in obj) {\r\n                return false;\r\n            }\r\n            return true;\r\n        },\r\n        type: function (obj) {\r\n            if (obj == null) {\r\n                return obj + \"\";\r\n            }\r\n            // Support: Android <=2.3 only (functionish RegExp)\r\n            return typeof obj === \"object\" || typeof obj === \"function\" ?\r\n                class2type[toString.call(obj)] || \"object\" :\r\n                typeof obj;\r\n        },\r\n        // Evaluates a script in a global context\r\n        globalEval: function (code) {\r\n            DOMEval(code);\r\n        },\r\n        // Convert dashed to camelCase; used by the css and data modules\r\n        // Support: IE <=9 - 11, Edge 12 - 13\r\n        // Microsoft forgot to hump their vendor prefix (#9572)\r\n        camelCase: function (string) {\r\n            return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\r\n        },\r\n        nodeName: function (elem, name) {\r\n            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\r\n        },\r\n        each: function (obj, callback) {\r\n            var length, i = 0;\r\n            if (isArrayLike(obj)) {\r\n                length = obj.length;\r\n                for (; i < length; i++) {\r\n                    if (callback.call(obj[i], i, obj[i]) === false) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (i in obj) {\r\n                    if (callback.call(obj[i], i, obj[i]) === false) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return obj;\r\n        },\r\n        // Support: Android <=4.0 only\r\n        trim: function (text) {\r\n            return text == null ?\r\n                \"\" :\r\n                (text + \"\").replace(rtrim, \"\");\r\n        },\r\n        // results is for internal usage only\r\n        makeArray: function (arr, results) {\r\n            var ret = results || [];\r\n            if (arr != null) {\r\n                if (isArrayLike(Object(arr))) {\r\n                    jQuery.merge(ret, typeof arr === \"string\" ?\r\n                        [arr] : arr);\r\n                }\r\n                else {\r\n                    push.call(ret, arr);\r\n                }\r\n            }\r\n            return ret;\r\n        },\r\n        inArray: function (elem, arr, i) {\r\n            return arr == null ? -1 : indexOf.call(arr, elem, i);\r\n        },\r\n        // Support: Android <=4.0 only, PhantomJS 1 only\r\n        // push.apply(_, arraylike) throws on ancient WebKit\r\n        merge: function (first, second) {\r\n            var len = +second.length, j = 0, i = first.length;\r\n            for (; j < len; j++) {\r\n                first[i++] = second[j];\r\n            }\r\n            first.length = i;\r\n            return first;\r\n        },\r\n        grep: function (elems, callback, invert) {\r\n            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;\r\n            // Go through the array, only saving the items\r\n            // that pass the validator function\r\n            for (; i < length; i++) {\r\n                callbackInverse = !callback(elems[i], i);\r\n                if (callbackInverse !== callbackExpect) {\r\n                    matches.push(elems[i]);\r\n                }\r\n            }\r\n            return matches;\r\n        },\r\n        // arg is for internal usage only\r\n        map: function (elems, callback, arg) {\r\n            var length, value, i = 0, ret = [];\r\n            // Go through the array, translating each of the items to their new values\r\n            if (isArrayLike(elems)) {\r\n                length = elems.length;\r\n                for (; i < length; i++) {\r\n                    value = callback(elems[i], i, arg);\r\n                    if (value != null) {\r\n                        ret.push(value);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (i in elems) {\r\n                    value = callback(elems[i], i, arg);\r\n                    if (value != null) {\r\n                        ret.push(value);\r\n                    }\r\n                }\r\n            }\r\n            // Flatten any nested arrays\r\n            return concat.apply([], ret);\r\n        },\r\n        // A global GUID counter for objects\r\n        guid: 1,\r\n        // Bind a function to a context, optionally partially applying any\r\n        // arguments.\r\n        proxy: function (fn, context) {\r\n            var tmp, args, proxy;\r\n            if (typeof context === \"string\") {\r\n                tmp = fn[context];\r\n                context = fn;\r\n                fn = tmp;\r\n            }\r\n            // Quick check to determine if target is callable, in the spec\r\n            // this throws a TypeError, but we will just return undefined.\r\n            if (!jQuery.isFunction(fn)) {\r\n                return undefined;\r\n            }\r\n            // Simulated bind\r\n            args = slice.call(arguments, 2);\r\n            proxy = function () {\r\n                return fn.apply(context || this, args.concat(slice.call(arguments)));\r\n            };\r\n            // Set the guid of unique handler to the same of original handler, so it can be removed\r\n            proxy.guid = fn.guid = fn.guid || jQuery.guid++;\r\n            return proxy;\r\n        },\r\n        now: Date.now,\r\n        // jQuery.support is not used in Core but other projects attach their\r\n        // properties to it so it needs to exist.\r\n        support: support\r\n    });\r\n    if (typeof Symbol === \"function\") {\r\n        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\r\n    }\r\n    // Populate the class2type map\r\n    jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (i, name) {\r\n        class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\r\n    });\r\n    function isArrayLike(obj) {\r\n        // Support: real iOS 8.2 only (not reproducible in simulator)\r\n        // `in` check used to prevent JIT error (gh-2145)\r\n        // hasOwn isn't used here due to false negatives\r\n        // regarding Nodelist length in IE\r\n        var length = !!obj && \"length\" in obj && obj.length, type = jQuery.type(obj);\r\n        if (type === \"function\" || jQuery.isWindow(obj)) {\r\n            return false;\r\n        }\r\n        return type === \"array\" || length === 0 ||\r\n            typeof length === \"number\" && length > 0 && (length - 1) in obj;\r\n    }\r\n    var Sizzle = \r\n    /*!\r\n     * Sizzle CSS Selector Engine v2.3.3\r\n     * https://sizzlejs.com/\r\n     *\r\n     * Copyright jQuery Foundation and other contributors\r\n     * Released under the MIT license\r\n     * http://jquery.org/license\r\n     *\r\n     * Date: 2016-08-08\r\n     */\r\n    (function (window) {\r\n        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, \r\n        // Local document vars\r\n        setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, \r\n        // Instance-specific data\r\n        expando = \"sizzle\" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {\r\n            if (a === b) {\r\n                hasDuplicate = true;\r\n            }\r\n            return 0;\r\n        }, \r\n        // Instance methods\r\n        hasOwn = ({}).hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, \r\n        // Use a stripped-down indexOf as it's faster than native\r\n        // https://jsperf.com/thor-indexof-vs-for/5\r\n        indexOf = function (list, elem) {\r\n            var i = 0, len = list.length;\r\n            for (; i < len; i++) {\r\n                if (list[i] === elem) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }, booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\", \r\n        // Regular expressions\r\n        // http://www.w3.org/TR/css3-selectors/#whitespace\r\n        whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\", \r\n        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\r\n        identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\", \r\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\r\n        attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\r\n            // Operator (capture 2)\r\n            \"*([*^$|!~]?=)\" + whitespace +\r\n            // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\r\n            \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\r\n            \"*\\\\]\", pseudos = \":(\" + identifier + \")(?:\\\\((\" +\r\n            // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\r\n            // 1. quoted (capture 3; capture 4 or capture 5)\r\n            \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\r\n            // 2. simple (capture 6)\r\n            \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\r\n            // 3. anything else (capture 2)\r\n            \".*\" +\r\n            \")\\\\)|)\", \r\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\r\n        rwhitespace = new RegExp(whitespace + \"+\", \"g\"), rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"), rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"), rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"), rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp(\"^\" + identifier + \"$\"), matchExpr = {\r\n            \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\r\n            \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\r\n            \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\r\n            \"ATTR\": new RegExp(\"^\" + attributes),\r\n            \"PSEUDO\": new RegExp(\"^\" + pseudos),\r\n            \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\r\n                \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\r\n                \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\r\n            \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\r\n            // For use in libraries implementing .is()\r\n            // We use this for POS matching in `select`\r\n            \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\r\n                whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\r\n        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\\d$/i, rnative = /^[^{]+\\{\\s*\\[native \\w/, \r\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\r\n        rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/, rsibling = /[+~]/, \r\n        // CSS escapes\r\n        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\r\n        runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"), funescape = function (_, escaped, escapedWhitespace) {\r\n            var high = \"0x\" + escaped - 0x10000;\r\n            // NaN means non-codepoint\r\n            // Support: Firefox<24\r\n            // Workaround erroneous numeric interpretation of +\"0x\"\r\n            return high !== high || escapedWhitespace ?\r\n                escaped :\r\n                high < 0 ?\r\n                    // BMP codepoint\r\n                    String.fromCharCode(high + 0x10000) :\r\n                    // Supplemental Plane codepoint (surrogate pair)\r\n                    String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\r\n        }, \r\n        // CSS string/identifier serialization\r\n        // https://drafts.csswg.org/cssom/#common-serializing-idioms\r\n        rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g, fcssescape = function (ch, asCodePoint) {\r\n            if (asCodePoint) {\r\n                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\r\n                if (ch === \"\\0\") {\r\n                    return \"\\uFFFD\";\r\n                }\r\n                // Control characters and (dependent upon position) numbers get escaped as code points\r\n                return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\r\n            }\r\n            // Other potentially-special ASCII characters get backslash-escaped\r\n            return \"\\\\\" + ch;\r\n        }, \r\n        // Used for iframes\r\n        // See setDocument()\r\n        // Removing the function wrapper causes a \"Permission Denied\"\r\n        // error in IE\r\n        unloadHandler = function () {\r\n            setDocument();\r\n        }, disabledAncestor = addCombinator(function (elem) {\r\n            return elem.disabled === true && (\"form\" in elem || \"label\" in elem);\r\n        }, { dir: \"parentNode\", next: \"legend\" });\r\n        // Optimize for push.apply( _, NodeList )\r\n        try {\r\n            push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);\r\n            // Support: Android<4.0\r\n            // Detect silently failing push.apply\r\n            arr[preferredDoc.childNodes.length].nodeType;\r\n        }\r\n        catch (e) {\r\n            push = { apply: arr.length ?\r\n                    // Leverage slice if possible\r\n                    function (target, els) {\r\n                        push_native.apply(target, slice.call(els));\r\n                    } :\r\n                    // Support: IE<9\r\n                    // Otherwise append directly\r\n                    function (target, els) {\r\n                        var j = target.length, i = 0;\r\n                        // Can't trust NodeList.length\r\n                        while ((target[j++] = els[i++])) { }\r\n                        target.length = j - 1;\r\n                    }\r\n            };\r\n        }\r\n        function Sizzle(selector, context, results, seed) {\r\n            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, \r\n            // nodeType defaults to 9, since context defaults to document\r\n            nodeType = context ? context.nodeType : 9;\r\n            results = results || [];\r\n            // Return early from calls with invalid selector or context\r\n            if (typeof selector !== \"string\" || !selector ||\r\n                nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\r\n                return results;\r\n            }\r\n            // Try to shortcut find operations (as opposed to filters) in HTML documents\r\n            if (!seed) {\r\n                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\r\n                    setDocument(context);\r\n                }\r\n                context = context || document;\r\n                if (documentIsHTML) {\r\n                    // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\r\n                    // (excepting DocumentFragment context, where the methods don't exist)\r\n                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\r\n                        // ID selector\r\n                        if ((m = match[1])) {\r\n                            // Document context\r\n                            if (nodeType === 9) {\r\n                                if ((elem = context.getElementById(m))) {\r\n                                    // Support: IE, Opera, Webkit\r\n                                    // TODO: identify versions\r\n                                    // getElementById can match elements by name instead of ID\r\n                                    if (elem.id === m) {\r\n                                        results.push(elem);\r\n                                        return results;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    return results;\r\n                                }\r\n                            }\r\n                            else {\r\n                                // Support: IE, Opera, Webkit\r\n                                // TODO: identify versions\r\n                                // getElementById can match elements by name instead of ID\r\n                                if (newContext && (elem = newContext.getElementById(m)) &&\r\n                                    contains(context, elem) &&\r\n                                    elem.id === m) {\r\n                                    results.push(elem);\r\n                                    return results;\r\n                                }\r\n                            }\r\n                        }\r\n                        else if (match[2]) {\r\n                            push.apply(results, context.getElementsByTagName(selector));\r\n                            return results;\r\n                        }\r\n                        else if ((m = match[3]) && support.getElementsByClassName &&\r\n                            context.getElementsByClassName) {\r\n                            push.apply(results, context.getElementsByClassName(m));\r\n                            return results;\r\n                        }\r\n                    }\r\n                    // Take advantage of querySelectorAll\r\n                    if (support.qsa &&\r\n                        !compilerCache[selector + \" \"] &&\r\n                        (!rbuggyQSA || !rbuggyQSA.test(selector))) {\r\n                        if (nodeType !== 1) {\r\n                            newContext = context;\r\n                            newSelector = selector;\r\n                        }\r\n                        else if (context.nodeName.toLowerCase() !== \"object\") {\r\n                            // Capture the context ID, setting it first if necessary\r\n                            if ((nid = context.getAttribute(\"id\"))) {\r\n                                nid = nid.replace(rcssescape, fcssescape);\r\n                            }\r\n                            else {\r\n                                context.setAttribute(\"id\", (nid = expando));\r\n                            }\r\n                            // Prefix every selector in the list\r\n                            groups = tokenize(selector);\r\n                            i = groups.length;\r\n                            while (i--) {\r\n                                groups[i] = \"#\" + nid + \" \" + toSelector(groups[i]);\r\n                            }\r\n                            newSelector = groups.join(\",\");\r\n                            // Expand context for sibling selectors\r\n                            newContext = rsibling.test(selector) && testContext(context.parentNode) ||\r\n                                context;\r\n                        }\r\n                        if (newSelector) {\r\n                            try {\r\n                                push.apply(results, newContext.querySelectorAll(newSelector));\r\n                                return results;\r\n                            }\r\n                            catch (qsaError) {\r\n                            }\r\n                            finally {\r\n                                if (nid === expando) {\r\n                                    context.removeAttribute(\"id\");\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // All others\r\n            return select(selector.replace(rtrim, \"$1\"), context, results, seed);\r\n        }\r\n        /**\r\n         * Create key-value caches of limited size\r\n         * @returns {function(string, object)} Returns the Object data after storing it on itself with\r\n         *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\r\n         *\tdeleting the oldest entry\r\n         */\r\n        function createCache() {\r\n            var keys = [];\r\n            function cache(key, value) {\r\n                // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\r\n                if (keys.push(key + \" \") > Expr.cacheLength) {\r\n                    // Only keep the most recent entries\r\n                    delete cache[keys.shift()];\r\n                }\r\n                return (cache[key + \" \"] = value);\r\n            }\r\n            return cache;\r\n        }\r\n        /**\r\n         * Mark a function for special use by Sizzle\r\n         * @param {Function} fn The function to mark\r\n         */\r\n        function markFunction(fn) {\r\n            fn[expando] = true;\r\n            return fn;\r\n        }\r\n        /**\r\n         * Support testing using an element\r\n         * @param {Function} fn Passed the created element and returns a boolean result\r\n         */\r\n        function assert(fn) {\r\n            var el = document.createElement(\"fieldset\");\r\n            try {\r\n                return !!fn(el);\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n            finally {\r\n                // Remove from its parent by default\r\n                if (el.parentNode) {\r\n                    el.parentNode.removeChild(el);\r\n                }\r\n                // release memory in IE\r\n                el = null;\r\n            }\r\n        }\r\n        /**\r\n         * Adds the same handler for all of the specified attrs\r\n         * @param {String} attrs Pipe-separated list of attributes\r\n         * @param {Function} handler The method that will be applied\r\n         */\r\n        function addHandle(attrs, handler) {\r\n            var arr = attrs.split(\"|\"), i = arr.length;\r\n            while (i--) {\r\n                Expr.attrHandle[arr[i]] = handler;\r\n            }\r\n        }\r\n        /**\r\n         * Checks document order of two siblings\r\n         * @param {Element} a\r\n         * @param {Element} b\r\n         * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\r\n         */\r\n        function siblingCheck(a, b) {\r\n            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 &&\r\n                a.sourceIndex - b.sourceIndex;\r\n            // Use IE sourceIndex if available on both nodes\r\n            if (diff) {\r\n                return diff;\r\n            }\r\n            // Check if b follows a\r\n            if (cur) {\r\n                while ((cur = cur.nextSibling)) {\r\n                    if (cur === b) {\r\n                        return -1;\r\n                    }\r\n                }\r\n            }\r\n            return a ? 1 : -1;\r\n        }\r\n        /**\r\n         * Returns a function to use in pseudos for input types\r\n         * @param {String} type\r\n         */\r\n        function createInputPseudo(type) {\r\n            return function (elem) {\r\n                var name = elem.nodeName.toLowerCase();\r\n                return name === \"input\" && elem.type === type;\r\n            };\r\n        }\r\n        /**\r\n         * Returns a function to use in pseudos for buttons\r\n         * @param {String} type\r\n         */\r\n        function createButtonPseudo(type) {\r\n            return function (elem) {\r\n                var name = elem.nodeName.toLowerCase();\r\n                return (name === \"input\" || name === \"button\") && elem.type === type;\r\n            };\r\n        }\r\n        /**\r\n         * Returns a function to use in pseudos for :enabled/:disabled\r\n         * @param {Boolean} disabled true for :disabled; false for :enabled\r\n         */\r\n        function createDisabledPseudo(disabled) {\r\n            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\r\n            return function (elem) {\r\n                // Only certain elements can match :enabled or :disabled\r\n                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\r\n                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\r\n                if (\"form\" in elem) {\r\n                    // Check for inherited disabledness on relevant non-disabled elements:\r\n                    // * listed form-associated elements in a disabled fieldset\r\n                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\r\n                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\r\n                    // * option elements in a disabled optgroup\r\n                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\r\n                    // All such elements have a \"form\" property.\r\n                    if (elem.parentNode && elem.disabled === false) {\r\n                        // Option elements defer to a parent optgroup if present\r\n                        if (\"label\" in elem) {\r\n                            if (\"label\" in elem.parentNode) {\r\n                                return elem.parentNode.disabled === disabled;\r\n                            }\r\n                            else {\r\n                                return elem.disabled === disabled;\r\n                            }\r\n                        }\r\n                        // Support: IE 6 - 11\r\n                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors\r\n                        return elem.isDisabled === disabled ||\r\n                            // Where there is no isDisabled, check manually\r\n                            /* jshint -W018 */\r\n                            elem.isDisabled !== !disabled &&\r\n                                disabledAncestor(elem) === disabled;\r\n                    }\r\n                    return elem.disabled === disabled;\r\n                }\r\n                else if (\"label\" in elem) {\r\n                    return elem.disabled === disabled;\r\n                }\r\n                // Remaining elements are neither :enabled nor :disabled\r\n                return false;\r\n            };\r\n        }\r\n        /**\r\n         * Returns a function to use in pseudos for positionals\r\n         * @param {Function} fn\r\n         */\r\n        function createPositionalPseudo(fn) {\r\n            return markFunction(function (argument) {\r\n                argument = +argument;\r\n                return markFunction(function (seed, matches) {\r\n                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;\r\n                    // Match elements found at the specified indexes\r\n                    while (i--) {\r\n                        if (seed[(j = matchIndexes[i])]) {\r\n                            seed[j] = !(matches[j] = seed[j]);\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        /**\r\n         * Checks a node for validity as a Sizzle context\r\n         * @param {Element|Object=} context\r\n         * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\r\n         */\r\n        function testContext(context) {\r\n            return context && typeof context.getElementsByTagName !== \"undefined\" && context;\r\n        }\r\n        // Expose support vars for convenience\r\n        support = Sizzle.support = {};\r\n        /**\r\n         * Detects XML nodes\r\n         * @param {Element|Object} elem An element or a document\r\n         * @returns {Boolean} True iff elem is a non-HTML XML node\r\n         */\r\n        isXML = Sizzle.isXML = function (elem) {\r\n            // documentElement is verified for cases where it doesn't yet exist\r\n            // (such as loading iframes in IE - #4833)\r\n            var documentElement = elem && (elem.ownerDocument || elem).documentElement;\r\n            return documentElement ? documentElement.nodeName !== \"HTML\" : false;\r\n        };\r\n        /**\r\n         * Sets document-related variables once based on the current document\r\n         * @param {Element|Object} [doc] An element or document object to use to set the document\r\n         * @returns {Object} Returns the current document\r\n         */\r\n        setDocument = Sizzle.setDocument = function (node) {\r\n            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;\r\n            // Return early if doc is invalid or already selected\r\n            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\r\n                return document;\r\n            }\r\n            // Update global variables\r\n            document = doc;\r\n            docElem = document.documentElement;\r\n            documentIsHTML = !isXML(document);\r\n            // Support: IE 9-11, Edge\r\n            // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\r\n            if (preferredDoc !== document &&\r\n                (subWindow = document.defaultView) && subWindow.top !== subWindow) {\r\n                // Support: IE 11, Edge\r\n                if (subWindow.addEventListener) {\r\n                    subWindow.addEventListener(\"unload\", unloadHandler, false);\r\n                }\r\n                else if (subWindow.attachEvent) {\r\n                    subWindow.attachEvent(\"onunload\", unloadHandler);\r\n                }\r\n            }\r\n            /* Attributes\r\n            ---------------------------------------------------------------------- */\r\n            // Support: IE<8\r\n            // Verify that getAttribute really returns attributes and not properties\r\n            // (excepting IE8 booleans)\r\n            support.attributes = assert(function (el) {\r\n                el.className = \"i\";\r\n                return !el.getAttribute(\"className\");\r\n            });\r\n            /* getElement(s)By*\r\n            ---------------------------------------------------------------------- */\r\n            // Check if getElementsByTagName(\"*\") returns only elements\r\n            support.getElementsByTagName = assert(function (el) {\r\n                el.appendChild(document.createComment(\"\"));\r\n                return !el.getElementsByTagName(\"*\").length;\r\n            });\r\n            // Support: IE<9\r\n            support.getElementsByClassName = rnative.test(document.getElementsByClassName);\r\n            // Support: IE<10\r\n            // Check if getElementById returns elements by name\r\n            // The broken getElementById methods don't pick up programmatically-set names,\r\n            // so use a roundabout getElementsByName test\r\n            support.getById = assert(function (el) {\r\n                docElem.appendChild(el).id = expando;\r\n                return !document.getElementsByName || !document.getElementsByName(expando).length;\r\n            });\r\n            // ID filter and find\r\n            if (support.getById) {\r\n                Expr.filter[\"ID\"] = function (id) {\r\n                    var attrId = id.replace(runescape, funescape);\r\n                    return function (elem) {\r\n                        return elem.getAttribute(\"id\") === attrId;\r\n                    };\r\n                };\r\n                Expr.find[\"ID\"] = function (id, context) {\r\n                    if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\r\n                        var elem = context.getElementById(id);\r\n                        return elem ? [elem] : [];\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                Expr.filter[\"ID\"] = function (id) {\r\n                    var attrId = id.replace(runescape, funescape);\r\n                    return function (elem) {\r\n                        var node = typeof elem.getAttributeNode !== \"undefined\" &&\r\n                            elem.getAttributeNode(\"id\");\r\n                        return node && node.value === attrId;\r\n                    };\r\n                };\r\n                // Support: IE 6 - 7 only\r\n                // getElementById is not reliable as a find shortcut\r\n                Expr.find[\"ID\"] = function (id, context) {\r\n                    if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\r\n                        var node, i, elems, elem = context.getElementById(id);\r\n                        if (elem) {\r\n                            // Verify the id attribute\r\n                            node = elem.getAttributeNode(\"id\");\r\n                            if (node && node.value === id) {\r\n                                return [elem];\r\n                            }\r\n                            // Fall back on getElementsByName\r\n                            elems = context.getElementsByName(id);\r\n                            i = 0;\r\n                            while ((elem = elems[i++])) {\r\n                                node = elem.getAttributeNode(\"id\");\r\n                                if (node && node.value === id) {\r\n                                    return [elem];\r\n                                }\r\n                            }\r\n                        }\r\n                        return [];\r\n                    }\r\n                };\r\n            }\r\n            // Tag\r\n            Expr.find[\"TAG\"] = support.getElementsByTagName ?\r\n                function (tag, context) {\r\n                    if (typeof context.getElementsByTagName !== \"undefined\") {\r\n                        return context.getElementsByTagName(tag);\r\n                    }\r\n                    else if (support.qsa) {\r\n                        return context.querySelectorAll(tag);\r\n                    }\r\n                } :\r\n                function (tag, context) {\r\n                    var elem, tmp = [], i = 0, \r\n                    // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\r\n                    results = context.getElementsByTagName(tag);\r\n                    // Filter out possible comments\r\n                    if (tag === \"*\") {\r\n                        while ((elem = results[i++])) {\r\n                            if (elem.nodeType === 1) {\r\n                                tmp.push(elem);\r\n                            }\r\n                        }\r\n                        return tmp;\r\n                    }\r\n                    return results;\r\n                };\r\n            // Class\r\n            Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\r\n                if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\r\n                    return context.getElementsByClassName(className);\r\n                }\r\n            };\r\n            /* QSA/matchesSelector\r\n            ---------------------------------------------------------------------- */\r\n            // QSA and matchesSelector support\r\n            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\r\n            rbuggyMatches = [];\r\n            // qSa(:focus) reports false when true (Chrome 21)\r\n            // We allow this because of a bug in IE8/9 that throws an error\r\n            // whenever `document.activeElement` is accessed on an iframe\r\n            // So, we allow :focus to pass through QSA all the time to avoid the IE error\r\n            // See https://bugs.jquery.com/ticket/13378\r\n            rbuggyQSA = [];\r\n            if ((support.qsa = rnative.test(document.querySelectorAll))) {\r\n                // Build QSA regex\r\n                // Regex strategy adopted from Diego Perini\r\n                assert(function (el) {\r\n                    // Select is set to empty string on purpose\r\n                    // This is to test IE's treatment of not explicitly\r\n                    // setting a boolean content attribute,\r\n                    // since its presence should be enough\r\n                    // https://bugs.jquery.com/ticket/12359\r\n                    docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" +\r\n                        \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\r\n                        \"<option selected=''></option></select>\";\r\n                    // Support: IE8, Opera 11-12.16\r\n                    // Nothing should be selected when empty strings follow ^= or $= or *=\r\n                    // The test attribute must be unknown in Opera but \"safe\" for WinRT\r\n                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\r\n                    if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\r\n                        rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\r\n                    }\r\n                    // Support: IE8\r\n                    // Boolean attributes and \"value\" are not treated correctly\r\n                    if (!el.querySelectorAll(\"[selected]\").length) {\r\n                        rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\r\n                    }\r\n                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\r\n                    if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\r\n                        rbuggyQSA.push(\"~=\");\r\n                    }\r\n                    // Webkit/Opera - :checked should return selected option elements\r\n                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n                    // IE8 throws error here and will not see later tests\r\n                    if (!el.querySelectorAll(\":checked\").length) {\r\n                        rbuggyQSA.push(\":checked\");\r\n                    }\r\n                    // Support: Safari 8+, iOS 8+\r\n                    // https://bugs.webkit.org/show_bug.cgi?id=136851\r\n                    // In-page `selector#id sibling-combinator selector` fails\r\n                    if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\r\n                        rbuggyQSA.push(\".#.+[+~]\");\r\n                    }\r\n                });\r\n                assert(function (el) {\r\n                    el.innerHTML = \"<a href='' disabled='disabled'></a>\" +\r\n                        \"<select disabled='disabled'><option/></select>\";\r\n                    // Support: Windows 8 Native Apps\r\n                    // The type and name attributes are restricted during .innerHTML assignment\r\n                    var input = document.createElement(\"input\");\r\n                    input.setAttribute(\"type\", \"hidden\");\r\n                    el.appendChild(input).setAttribute(\"name\", \"D\");\r\n                    // Support: IE8\r\n                    // Enforce case-sensitivity of name attribute\r\n                    if (el.querySelectorAll(\"[name=d]\").length) {\r\n                        rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\r\n                    }\r\n                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\r\n                    // IE8 throws error here and will not see later tests\r\n                    if (el.querySelectorAll(\":enabled\").length !== 2) {\r\n                        rbuggyQSA.push(\":enabled\", \":disabled\");\r\n                    }\r\n                    // Support: IE9-11+\r\n                    // IE's :disabled selector does not pick up the children of disabled fieldsets\r\n                    docElem.appendChild(el).disabled = true;\r\n                    if (el.querySelectorAll(\":disabled\").length !== 2) {\r\n                        rbuggyQSA.push(\":enabled\", \":disabled\");\r\n                    }\r\n                    // Opera 10-11 does not throw on post-comma invalid pseudos\r\n                    el.querySelectorAll(\"*,:x\");\r\n                    rbuggyQSA.push(\",.*:\");\r\n                });\r\n            }\r\n            if ((support.matchesSelector = rnative.test((matches = docElem.matches ||\r\n                docElem.webkitMatchesSelector ||\r\n                docElem.mozMatchesSelector ||\r\n                docElem.oMatchesSelector ||\r\n                docElem.msMatchesSelector)))) {\r\n                assert(function (el) {\r\n                    // Check to see if it's possible to do matchesSelector\r\n                    // on a disconnected node (IE 9)\r\n                    support.disconnectedMatch = matches.call(el, \"*\");\r\n                    // This should fail with an exception\r\n                    // Gecko does not error, returns false instead\r\n                    matches.call(el, \"[s!='']:x\");\r\n                    rbuggyMatches.push(\"!=\", pseudos);\r\n                });\r\n            }\r\n            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\r\n            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\r\n            /* Contains\r\n            ---------------------------------------------------------------------- */\r\n            hasCompare = rnative.test(docElem.compareDocumentPosition);\r\n            // Element contains another\r\n            // Purposefully self-exclusive\r\n            // As in, an element does not contain itself\r\n            contains = hasCompare || rnative.test(docElem.contains) ?\r\n                function (a, b) {\r\n                    var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;\r\n                    return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ?\r\n                        adown.contains(bup) :\r\n                        a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\r\n                } :\r\n                function (a, b) {\r\n                    if (b) {\r\n                        while ((b = b.parentNode)) {\r\n                            if (b === a) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    return false;\r\n                };\r\n            /* Sorting\r\n            ---------------------------------------------------------------------- */\r\n            // Document order sorting\r\n            sortOrder = hasCompare ?\r\n                function (a, b) {\r\n                    // Flag for duplicate removal\r\n                    if (a === b) {\r\n                        hasDuplicate = true;\r\n                        return 0;\r\n                    }\r\n                    // Sort on method existence if only one input has compareDocumentPosition\r\n                    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\r\n                    if (compare) {\r\n                        return compare;\r\n                    }\r\n                    // Calculate position if both inputs belong to the same document\r\n                    compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?\r\n                        a.compareDocumentPosition(b) :\r\n                        // Otherwise we know they are disconnected\r\n                        1;\r\n                    // Disconnected nodes\r\n                    if (compare & 1 ||\r\n                        (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {\r\n                        // Choose the first element that is related to our preferred document\r\n                        if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\r\n                            return -1;\r\n                        }\r\n                        if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\r\n                            return 1;\r\n                        }\r\n                        // Maintain original order\r\n                        return sortInput ?\r\n                            (indexOf(sortInput, a) - indexOf(sortInput, b)) :\r\n                            0;\r\n                    }\r\n                    return compare & 4 ? -1 : 1;\r\n                } :\r\n                function (a, b) {\r\n                    // Exit early if the nodes are identical\r\n                    if (a === b) {\r\n                        hasDuplicate = true;\r\n                        return 0;\r\n                    }\r\n                    var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];\r\n                    // Parentless nodes are either documents or disconnected\r\n                    if (!aup || !bup) {\r\n                        return a === document ? -1 :\r\n                            b === document ? 1 :\r\n                                aup ? -1 :\r\n                                    bup ? 1 :\r\n                                        sortInput ?\r\n                                            (indexOf(sortInput, a) - indexOf(sortInput, b)) :\r\n                                            0;\r\n                    }\r\n                    else if (aup === bup) {\r\n                        return siblingCheck(a, b);\r\n                    }\r\n                    // Otherwise we need full lists of their ancestors for comparison\r\n                    cur = a;\r\n                    while ((cur = cur.parentNode)) {\r\n                        ap.unshift(cur);\r\n                    }\r\n                    cur = b;\r\n                    while ((cur = cur.parentNode)) {\r\n                        bp.unshift(cur);\r\n                    }\r\n                    // Walk down the tree looking for a discrepancy\r\n                    while (ap[i] === bp[i]) {\r\n                        i++;\r\n                    }\r\n                    return i ?\r\n                        // Do a sibling check if the nodes have a common ancestor\r\n                        siblingCheck(ap[i], bp[i]) :\r\n                        // Otherwise nodes in our document sort first\r\n                        ap[i] === preferredDoc ? -1 :\r\n                            bp[i] === preferredDoc ? 1 :\r\n                                0;\r\n                };\r\n            return document;\r\n        };\r\n        Sizzle.matches = function (expr, elements) {\r\n            return Sizzle(expr, null, null, elements);\r\n        };\r\n        Sizzle.matchesSelector = function (elem, expr) {\r\n            // Set document vars if needed\r\n            if ((elem.ownerDocument || elem) !== document) {\r\n                setDocument(elem);\r\n            }\r\n            // Make sure that attribute selectors are quoted\r\n            expr = expr.replace(rattributeQuotes, \"='$1']\");\r\n            if (support.matchesSelector && documentIsHTML &&\r\n                !compilerCache[expr + \" \"] &&\r\n                (!rbuggyMatches || !rbuggyMatches.test(expr)) &&\r\n                (!rbuggyQSA || !rbuggyQSA.test(expr))) {\r\n                try {\r\n                    var ret = matches.call(elem, expr);\r\n                    // IE 9's matchesSelector returns false on disconnected nodes\r\n                    if (ret || support.disconnectedMatch ||\r\n                        // As well, disconnected nodes are said to be in a document\r\n                        // fragment in IE 9\r\n                        elem.document && elem.document.nodeType !== 11) {\r\n                        return ret;\r\n                    }\r\n                }\r\n                catch (e) { }\r\n            }\r\n            return Sizzle(expr, document, null, [elem]).length > 0;\r\n        };\r\n        Sizzle.contains = function (context, elem) {\r\n            // Set document vars if needed\r\n            if ((context.ownerDocument || context) !== document) {\r\n                setDocument(context);\r\n            }\r\n            return contains(context, elem);\r\n        };\r\n        Sizzle.attr = function (elem, name) {\r\n            // Set document vars if needed\r\n            if ((elem.ownerDocument || elem) !== document) {\r\n                setDocument(elem);\r\n            }\r\n            var fn = Expr.attrHandle[name.toLowerCase()], \r\n            // Don't get fooled by Object.prototype properties (jQuery #13807)\r\n            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?\r\n                fn(elem, name, !documentIsHTML) :\r\n                undefined;\r\n            return val !== undefined ?\r\n                val :\r\n                support.attributes || !documentIsHTML ?\r\n                    elem.getAttribute(name) :\r\n                    (val = elem.getAttributeNode(name)) && val.specified ?\r\n                        val.value :\r\n                        null;\r\n        };\r\n        Sizzle.escape = function (sel) {\r\n            return (sel + \"\").replace(rcssescape, fcssescape);\r\n        };\r\n        Sizzle.error = function (msg) {\r\n            throw new Error(\"Syntax error, unrecognized expression: \" + msg);\r\n        };\r\n        /**\r\n         * Document sorting and removing duplicates\r\n         * @param {ArrayLike} results\r\n         */\r\n        Sizzle.uniqueSort = function (results) {\r\n            var elem, duplicates = [], j = 0, i = 0;\r\n            // Unless we *know* we can detect duplicates, assume their presence\r\n            hasDuplicate = !support.detectDuplicates;\r\n            sortInput = !support.sortStable && results.slice(0);\r\n            results.sort(sortOrder);\r\n            if (hasDuplicate) {\r\n                while ((elem = results[i++])) {\r\n                    if (elem === results[i]) {\r\n                        j = duplicates.push(i);\r\n                    }\r\n                }\r\n                while (j--) {\r\n                    results.splice(duplicates[j], 1);\r\n                }\r\n            }\r\n            // Clear input after sorting to release objects\r\n            // See https://github.com/jquery/sizzle/pull/225\r\n            sortInput = null;\r\n            return results;\r\n        };\r\n        /**\r\n         * Utility function for retrieving the text value of an array of DOM nodes\r\n         * @param {Array|Element} elem\r\n         */\r\n        getText = Sizzle.getText = function (elem) {\r\n            var node, ret = \"\", i = 0, nodeType = elem.nodeType;\r\n            if (!nodeType) {\r\n                // If no nodeType, this is expected to be an array\r\n                while ((node = elem[i++])) {\r\n                    // Do not traverse comment nodes\r\n                    ret += getText(node);\r\n                }\r\n            }\r\n            else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\r\n                // Use textContent for elements\r\n                // innerText usage removed for consistency of new lines (jQuery #11153)\r\n                if (typeof elem.textContent === \"string\") {\r\n                    return elem.textContent;\r\n                }\r\n                else {\r\n                    // Traverse its children\r\n                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\r\n                        ret += getText(elem);\r\n                    }\r\n                }\r\n            }\r\n            else if (nodeType === 3 || nodeType === 4) {\r\n                return elem.nodeValue;\r\n            }\r\n            // Do not include comment or processing instruction nodes\r\n            return ret;\r\n        };\r\n        Expr = Sizzle.selectors = {\r\n            // Can be adjusted by the user\r\n            cacheLength: 50,\r\n            createPseudo: markFunction,\r\n            match: matchExpr,\r\n            attrHandle: {},\r\n            find: {},\r\n            relative: {\r\n                \">\": { dir: \"parentNode\", first: true },\r\n                \" \": { dir: \"parentNode\" },\r\n                \"+\": { dir: \"previousSibling\", first: true },\r\n                \"~\": { dir: \"previousSibling\" }\r\n            },\r\n            preFilter: {\r\n                \"ATTR\": function (match) {\r\n                    match[1] = match[1].replace(runescape, funescape);\r\n                    // Move the given value to match[3] whether quoted or unquoted\r\n                    match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\r\n                    if (match[2] === \"~=\") {\r\n                        match[3] = \" \" + match[3] + \" \";\r\n                    }\r\n                    return match.slice(0, 4);\r\n                },\r\n                \"CHILD\": function (match) {\r\n                    /* matches from matchExpr[\"CHILD\"]\r\n                        1 type (only|nth|...)\r\n                        2 what (child|of-type)\r\n                        3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\r\n                        4 xn-component of xn+y argument ([+-]?\\d*n|)\r\n                        5 sign of xn-component\r\n                        6 x of xn-component\r\n                        7 sign of y-component\r\n                        8 y of y-component\r\n                    */\r\n                    match[1] = match[1].toLowerCase();\r\n                    if (match[1].slice(0, 3) === \"nth\") {\r\n                        // nth-* requires argument\r\n                        if (!match[3]) {\r\n                            Sizzle.error(match[0]);\r\n                        }\r\n                        // numeric x and y parameters for Expr.filter.CHILD\r\n                        // remember that false/true cast respectively to 0/1\r\n                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\r\n                        match[5] = +((match[7] + match[8]) || match[3] === \"odd\");\r\n                    }\r\n                    else if (match[3]) {\r\n                        Sizzle.error(match[0]);\r\n                    }\r\n                    return match;\r\n                },\r\n                \"PSEUDO\": function (match) {\r\n                    var excess, unquoted = !match[6] && match[2];\r\n                    if (matchExpr[\"CHILD\"].test(match[0])) {\r\n                        return null;\r\n                    }\r\n                    // Accept quoted arguments as-is\r\n                    if (match[3]) {\r\n                        match[2] = match[4] || match[5] || \"\";\r\n                    }\r\n                    else if (unquoted && rpseudo.test(unquoted) &&\r\n                        // Get excess from tokenize (recursively)\r\n                        (excess = tokenize(unquoted, true)) &&\r\n                        // advance to the next closing parenthesis\r\n                        (excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\r\n                        // excess is a negative index\r\n                        match[0] = match[0].slice(0, excess);\r\n                        match[2] = unquoted.slice(0, excess);\r\n                    }\r\n                    // Return only captures needed by the pseudo filter method (type and argument)\r\n                    return match.slice(0, 3);\r\n                }\r\n            },\r\n            filter: {\r\n                \"TAG\": function (nodeNameSelector) {\r\n                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\r\n                    return nodeNameSelector === \"*\" ?\r\n                        function () { return true; } :\r\n                        function (elem) {\r\n                            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\r\n                        };\r\n                },\r\n                \"CLASS\": function (className) {\r\n                    var pattern = classCache[className + \" \"];\r\n                    return pattern ||\r\n                        (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) &&\r\n                            classCache(className, function (elem) {\r\n                                return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\r\n                            });\r\n                },\r\n                \"ATTR\": function (name, operator, check) {\r\n                    return function (elem) {\r\n                        var result = Sizzle.attr(elem, name);\r\n                        if (result == null) {\r\n                            return operator === \"!=\";\r\n                        }\r\n                        if (!operator) {\r\n                            return true;\r\n                        }\r\n                        result += \"\";\r\n                        return operator === \"=\" ? result === check :\r\n                            operator === \"!=\" ? result !== check :\r\n                                operator === \"^=\" ? check && result.indexOf(check) === 0 :\r\n                                    operator === \"*=\" ? check && result.indexOf(check) > -1 :\r\n                                        operator === \"$=\" ? check && result.slice(-check.length) === check :\r\n                                            operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 :\r\n                                                operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" :\r\n                                                    false;\r\n                    };\r\n                },\r\n                \"CHILD\": function (type, what, argument, first, last) {\r\n                    var simple = type.slice(0, 3) !== \"nth\", forward = type.slice(-4) !== \"last\", ofType = what === \"of-type\";\r\n                    return first === 1 && last === 0 ?\r\n                        // Shortcut for :nth-*(n)\r\n                        function (elem) {\r\n                            return !!elem.parentNode;\r\n                        } :\r\n                        function (elem, context, xml) {\r\n                            var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? \"nextSibling\" : \"previousSibling\", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;\r\n                            if (parent) {\r\n                                // :(first|last|only)-(child|of-type)\r\n                                if (simple) {\r\n                                    while (dir) {\r\n                                        node = elem;\r\n                                        while ((node = node[dir])) {\r\n                                            if (ofType ?\r\n                                                node.nodeName.toLowerCase() === name :\r\n                                                node.nodeType === 1) {\r\n                                                return false;\r\n                                            }\r\n                                        }\r\n                                        // Reverse direction for :only-* (if we haven't yet done so)\r\n                                        start = dir = type === \"only\" && !start && \"nextSibling\";\r\n                                    }\r\n                                    return true;\r\n                                }\r\n                                start = [forward ? parent.firstChild : parent.lastChild];\r\n                                // non-xml :nth-child(...) stores cache data on `parent`\r\n                                if (forward && useCache) {\r\n                                    // Seek `elem` from a previously-cached index\r\n                                    // ...in a gzip-friendly way\r\n                                    node = parent;\r\n                                    outerCache = node[expando] || (node[expando] = {});\r\n                                    // Support: IE <9 only\r\n                                    // Defend against cloned attroperties (jQuery gh-1709)\r\n                                    uniqueCache = outerCache[node.uniqueID] ||\r\n                                        (outerCache[node.uniqueID] = {});\r\n                                    cache = uniqueCache[type] || [];\r\n                                    nodeIndex = cache[0] === dirruns && cache[1];\r\n                                    diff = nodeIndex && cache[2];\r\n                                    node = nodeIndex && parent.childNodes[nodeIndex];\r\n                                    while ((node = ++nodeIndex && node && node[dir] ||\r\n                                        // Fallback to seeking `elem` from the start\r\n                                        (diff = nodeIndex = 0) || start.pop())) {\r\n                                        // When found, cache indexes on `parent` and break\r\n                                        if (node.nodeType === 1 && ++diff && node === elem) {\r\n                                            uniqueCache[type] = [dirruns, nodeIndex, diff];\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    // Use previously-cached element index if available\r\n                                    if (useCache) {\r\n                                        // ...in a gzip-friendly way\r\n                                        node = elem;\r\n                                        outerCache = node[expando] || (node[expando] = {});\r\n                                        // Support: IE <9 only\r\n                                        // Defend against cloned attroperties (jQuery gh-1709)\r\n                                        uniqueCache = outerCache[node.uniqueID] ||\r\n                                            (outerCache[node.uniqueID] = {});\r\n                                        cache = uniqueCache[type] || [];\r\n                                        nodeIndex = cache[0] === dirruns && cache[1];\r\n                                        diff = nodeIndex;\r\n                                    }\r\n                                    // xml :nth-child(...)\r\n                                    // or :nth-last-child(...) or :nth(-last)?-of-type(...)\r\n                                    if (diff === false) {\r\n                                        // Use the same loop as above to seek `elem` from the start\r\n                                        while ((node = ++nodeIndex && node && node[dir] ||\r\n                                            (diff = nodeIndex = 0) || start.pop())) {\r\n                                            if ((ofType ?\r\n                                                node.nodeName.toLowerCase() === name :\r\n                                                node.nodeType === 1) &&\r\n                                                ++diff) {\r\n                                                // Cache the index of each encountered element\r\n                                                if (useCache) {\r\n                                                    outerCache = node[expando] || (node[expando] = {});\r\n                                                    // Support: IE <9 only\r\n                                                    // Defend against cloned attroperties (jQuery gh-1709)\r\n                                                    uniqueCache = outerCache[node.uniqueID] ||\r\n                                                        (outerCache[node.uniqueID] = {});\r\n                                                    uniqueCache[type] = [dirruns, diff];\r\n                                                }\r\n                                                if (node === elem) {\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                // Incorporate the offset, then check against cycle size\r\n                                diff -= last;\r\n                                return diff === first || (diff % first === 0 && diff / first >= 0);\r\n                            }\r\n                        };\r\n                },\r\n                \"PSEUDO\": function (pseudo, argument) {\r\n                    // pseudo-class names are case-insensitive\r\n                    // http://www.w3.org/TR/selectors/#pseudo-classes\r\n                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\r\n                    // Remember that setFilters inherits from pseudos\r\n                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||\r\n                        Sizzle.error(\"unsupported pseudo: \" + pseudo);\r\n                    // The user may use createPseudo to indicate that\r\n                    // arguments are needed to create the filter function\r\n                    // just as Sizzle does\r\n                    if (fn[expando]) {\r\n                        return fn(argument);\r\n                    }\r\n                    // But maintain support for old signatures\r\n                    if (fn.length > 1) {\r\n                        args = [pseudo, pseudo, \"\", argument];\r\n                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?\r\n                            markFunction(function (seed, matches) {\r\n                                var idx, matched = fn(seed, argument), i = matched.length;\r\n                                while (i--) {\r\n                                    idx = indexOf(seed, matched[i]);\r\n                                    seed[idx] = !(matches[idx] = matched[i]);\r\n                                }\r\n                            }) :\r\n                            function (elem) {\r\n                                return fn(elem, 0, args);\r\n                            };\r\n                    }\r\n                    return fn;\r\n                }\r\n            },\r\n            pseudos: {\r\n                // Potentially complex pseudos\r\n                \"not\": markFunction(function (selector) {\r\n                    // Trim the selector passed to compile\r\n                    // to avoid treating leading and trailing\r\n                    // spaces as combinators\r\n                    var input = [], results = [], matcher = compile(selector.replace(rtrim, \"$1\"));\r\n                    return matcher[expando] ?\r\n                        markFunction(function (seed, matches, context, xml) {\r\n                            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;\r\n                            // Match elements unmatched by `matcher`\r\n                            while (i--) {\r\n                                if ((elem = unmatched[i])) {\r\n                                    seed[i] = !(matches[i] = elem);\r\n                                }\r\n                            }\r\n                        }) :\r\n                        function (elem, context, xml) {\r\n                            input[0] = elem;\r\n                            matcher(input, null, xml, results);\r\n                            // Don't keep the element (issue #299)\r\n                            input[0] = null;\r\n                            return !results.pop();\r\n                        };\r\n                }),\r\n                \"has\": markFunction(function (selector) {\r\n                    return function (elem) {\r\n                        return Sizzle(selector, elem).length > 0;\r\n                    };\r\n                }),\r\n                \"contains\": markFunction(function (text) {\r\n                    text = text.replace(runescape, funescape);\r\n                    return function (elem) {\r\n                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\r\n                    };\r\n                }),\r\n                // \"Whether an element is represented by a :lang() selector\r\n                // is based solely on the element's language value\r\n                // being equal to the identifier C,\r\n                // or beginning with the identifier C immediately followed by \"-\".\r\n                // The matching of C against the element's language value is performed case-insensitively.\r\n                // The identifier C does not have to be a valid language name.\"\r\n                // http://www.w3.org/TR/selectors/#lang-pseudo\r\n                \"lang\": markFunction(function (lang) {\r\n                    // lang value must be a valid identifier\r\n                    if (!ridentifier.test(lang || \"\")) {\r\n                        Sizzle.error(\"unsupported lang: \" + lang);\r\n                    }\r\n                    lang = lang.replace(runescape, funescape).toLowerCase();\r\n                    return function (elem) {\r\n                        var elemLang;\r\n                        do {\r\n                            if ((elemLang = documentIsHTML ?\r\n                                elem.lang :\r\n                                elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\"))) {\r\n                                elemLang = elemLang.toLowerCase();\r\n                                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\r\n                            }\r\n                        } while ((elem = elem.parentNode) && elem.nodeType === 1);\r\n                        return false;\r\n                    };\r\n                }),\r\n                // Miscellaneous\r\n                \"target\": function (elem) {\r\n                    var hash = window.location && window.location.hash;\r\n                    return hash && hash.slice(1) === elem.id;\r\n                },\r\n                \"root\": function (elem) {\r\n                    return elem === docElem;\r\n                },\r\n                \"focus\": function (elem) {\r\n                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\r\n                },\r\n                // Boolean properties\r\n                \"enabled\": createDisabledPseudo(false),\r\n                \"disabled\": createDisabledPseudo(true),\r\n                \"checked\": function (elem) {\r\n                    // In CSS3, :checked should return both checked and selected elements\r\n                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n                    var nodeName = elem.nodeName.toLowerCase();\r\n                    return (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\r\n                },\r\n                \"selected\": function (elem) {\r\n                    // Accessing this property makes selected-by-default\r\n                    // options in Safari work properly\r\n                    if (elem.parentNode) {\r\n                        elem.parentNode.selectedIndex;\r\n                    }\r\n                    return elem.selected === true;\r\n                },\r\n                // Contents\r\n                \"empty\": function (elem) {\r\n                    // http://www.w3.org/TR/selectors/#empty-pseudo\r\n                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\r\n                    //   but not by others (comment: 8; processing instruction: 7; etc.)\r\n                    // nodeType < 6 works because attributes (2) do not appear as children\r\n                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\r\n                        if (elem.nodeType < 6) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                },\r\n                \"parent\": function (elem) {\r\n                    return !Expr.pseudos[\"empty\"](elem);\r\n                },\r\n                // Element/input types\r\n                \"header\": function (elem) {\r\n                    return rheader.test(elem.nodeName);\r\n                },\r\n                \"input\": function (elem) {\r\n                    return rinputs.test(elem.nodeName);\r\n                },\r\n                \"button\": function (elem) {\r\n                    var name = elem.nodeName.toLowerCase();\r\n                    return name === \"input\" && elem.type === \"button\" || name === \"button\";\r\n                },\r\n                \"text\": function (elem) {\r\n                    var attr;\r\n                    return elem.nodeName.toLowerCase() === \"input\" &&\r\n                        elem.type === \"text\" &&\r\n                        // Support: IE<8\r\n                        // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\r\n                        ((attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\r\n                },\r\n                // Position-in-collection\r\n                \"first\": createPositionalPseudo(function () {\r\n                    return [0];\r\n                }),\r\n                \"last\": createPositionalPseudo(function (matchIndexes, length) {\r\n                    return [length - 1];\r\n                }),\r\n                \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\r\n                    return [argument < 0 ? argument + length : argument];\r\n                }),\r\n                \"even\": createPositionalPseudo(function (matchIndexes, length) {\r\n                    var i = 0;\r\n                    for (; i < length; i += 2) {\r\n                        matchIndexes.push(i);\r\n                    }\r\n                    return matchIndexes;\r\n                }),\r\n                \"odd\": createPositionalPseudo(function (matchIndexes, length) {\r\n                    var i = 1;\r\n                    for (; i < length; i += 2) {\r\n                        matchIndexes.push(i);\r\n                    }\r\n                    return matchIndexes;\r\n                }),\r\n                \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\r\n                    var i = argument < 0 ? argument + length : argument;\r\n                    for (; --i >= 0;) {\r\n                        matchIndexes.push(i);\r\n                    }\r\n                    return matchIndexes;\r\n                }),\r\n                \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\r\n                    var i = argument < 0 ? argument + length : argument;\r\n                    for (; ++i < length;) {\r\n                        matchIndexes.push(i);\r\n                    }\r\n                    return matchIndexes;\r\n                })\r\n            }\r\n        };\r\n        Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\r\n        // Add button/input type pseudos\r\n        for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\r\n            Expr.pseudos[i] = createInputPseudo(i);\r\n        }\r\n        for (i in { submit: true, reset: true }) {\r\n            Expr.pseudos[i] = createButtonPseudo(i);\r\n        }\r\n        // Easy API for creating new setFilters\r\n        function setFilters() { }\r\n        setFilters.prototype = Expr.filters = Expr.pseudos;\r\n        Expr.setFilters = new setFilters();\r\n        tokenize = Sizzle.tokenize = function (selector, parseOnly) {\r\n            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + \" \"];\r\n            if (cached) {\r\n                return parseOnly ? 0 : cached.slice(0);\r\n            }\r\n            soFar = selector;\r\n            groups = [];\r\n            preFilters = Expr.preFilter;\r\n            while (soFar) {\r\n                // Comma and first run\r\n                if (!matched || (match = rcomma.exec(soFar))) {\r\n                    if (match) {\r\n                        // Don't consume trailing commas as valid\r\n                        soFar = soFar.slice(match[0].length) || soFar;\r\n                    }\r\n                    groups.push((tokens = []));\r\n                }\r\n                matched = false;\r\n                // Combinators\r\n                if ((match = rcombinators.exec(soFar))) {\r\n                    matched = match.shift();\r\n                    tokens.push({\r\n                        value: matched,\r\n                        // Cast descendant combinators to space\r\n                        type: match[0].replace(rtrim, \" \")\r\n                    });\r\n                    soFar = soFar.slice(matched.length);\r\n                }\r\n                // Filters\r\n                for (type in Expr.filter) {\r\n                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||\r\n                        (match = preFilters[type](match)))) {\r\n                        matched = match.shift();\r\n                        tokens.push({\r\n                            value: matched,\r\n                            type: type,\r\n                            matches: match\r\n                        });\r\n                        soFar = soFar.slice(matched.length);\r\n                    }\r\n                }\r\n                if (!matched) {\r\n                    break;\r\n                }\r\n            }\r\n            // Return the length of the invalid excess\r\n            // if we're just parsing\r\n            // Otherwise, throw an error or return tokens\r\n            return parseOnly ?\r\n                soFar.length :\r\n                soFar ?\r\n                    Sizzle.error(selector) :\r\n                    // Cache the tokens\r\n                    tokenCache(selector, groups).slice(0);\r\n        };\r\n        function toSelector(tokens) {\r\n            var i = 0, len = tokens.length, selector = \"\";\r\n            for (; i < len; i++) {\r\n                selector += tokens[i].value;\r\n            }\r\n            return selector;\r\n        }\r\n        function addCombinator(matcher, combinator, base) {\r\n            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === \"parentNode\", doneName = done++;\r\n            return combinator.first ?\r\n                // Check against closest ancestor/preceding element\r\n                function (elem, context, xml) {\r\n                    while ((elem = elem[dir])) {\r\n                        if (elem.nodeType === 1 || checkNonElements) {\r\n                            return matcher(elem, context, xml);\r\n                        }\r\n                    }\r\n                    return false;\r\n                } :\r\n                // Check against all ancestor/preceding elements\r\n                function (elem, context, xml) {\r\n                    var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];\r\n                    // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\r\n                    if (xml) {\r\n                        while ((elem = elem[dir])) {\r\n                            if (elem.nodeType === 1 || checkNonElements) {\r\n                                if (matcher(elem, context, xml)) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        while ((elem = elem[dir])) {\r\n                            if (elem.nodeType === 1 || checkNonElements) {\r\n                                outerCache = elem[expando] || (elem[expando] = {});\r\n                                // Support: IE <9 only\r\n                                // Defend against cloned attroperties (jQuery gh-1709)\r\n                                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\r\n                                if (skip && skip === elem.nodeName.toLowerCase()) {\r\n                                    elem = elem[dir] || elem;\r\n                                }\r\n                                else if ((oldCache = uniqueCache[key]) &&\r\n                                    oldCache[0] === dirruns && oldCache[1] === doneName) {\r\n                                    // Assign to newCache so results back-propagate to previous elements\r\n                                    return (newCache[2] = oldCache[2]);\r\n                                }\r\n                                else {\r\n                                    // Reuse newcache so results back-propagate to previous elements\r\n                                    uniqueCache[key] = newCache;\r\n                                    // A match means we're done; a fail means we have to keep checking\r\n                                    if ((newCache[2] = matcher(elem, context, xml))) {\r\n                                        return true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    return false;\r\n                };\r\n        }\r\n        function elementMatcher(matchers) {\r\n            return matchers.length > 1 ?\r\n                function (elem, context, xml) {\r\n                    var i = matchers.length;\r\n                    while (i--) {\r\n                        if (!matchers[i](elem, context, xml)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                } :\r\n                matchers[0];\r\n        }\r\n        function multipleContexts(selector, contexts, results) {\r\n            var i = 0, len = contexts.length;\r\n            for (; i < len; i++) {\r\n                Sizzle(selector, contexts[i], results);\r\n            }\r\n            return results;\r\n        }\r\n        function condense(unmatched, map, filter, context, xml) {\r\n            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;\r\n            for (; i < len; i++) {\r\n                if ((elem = unmatched[i])) {\r\n                    if (!filter || filter(elem, context, xml)) {\r\n                        newUnmatched.push(elem);\r\n                        if (mapped) {\r\n                            map.push(i);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return newUnmatched;\r\n        }\r\n        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\r\n            if (postFilter && !postFilter[expando]) {\r\n                postFilter = setMatcher(postFilter);\r\n            }\r\n            if (postFinder && !postFinder[expando]) {\r\n                postFinder = setMatcher(postFinder, postSelector);\r\n            }\r\n            return markFunction(function (seed, results, context, xml) {\r\n                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, \r\n                // Get initial elements from seed or context\r\n                elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []), \r\n                // Prefilter to get matcher input, preserving a map for seed-results synchronization\r\n                matcherIn = preFilter && (seed || !selector) ?\r\n                    condense(elems, preMap, preFilter, context, xml) :\r\n                    elems, matcherOut = matcher ?\r\n                    // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\r\n                    postFinder || (seed ? preFilter : preexisting || postFilter) ?\r\n                        // ...intermediate processing is necessary\r\n                        [] :\r\n                        // ...otherwise use results directly\r\n                        results :\r\n                    matcherIn;\r\n                // Find primary matches\r\n                if (matcher) {\r\n                    matcher(matcherIn, matcherOut, context, xml);\r\n                }\r\n                // Apply postFilter\r\n                if (postFilter) {\r\n                    temp = condense(matcherOut, postMap);\r\n                    postFilter(temp, [], context, xml);\r\n                    // Un-match failing elements by moving them back to matcherIn\r\n                    i = temp.length;\r\n                    while (i--) {\r\n                        if ((elem = temp[i])) {\r\n                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\r\n                        }\r\n                    }\r\n                }\r\n                if (seed) {\r\n                    if (postFinder || preFilter) {\r\n                        if (postFinder) {\r\n                            // Get the final matcherOut by condensing this intermediate into postFinder contexts\r\n                            temp = [];\r\n                            i = matcherOut.length;\r\n                            while (i--) {\r\n                                if ((elem = matcherOut[i])) {\r\n                                    // Restore matcherIn since elem is not yet a final match\r\n                                    temp.push((matcherIn[i] = elem));\r\n                                }\r\n                            }\r\n                            postFinder(null, (matcherOut = []), temp, xml);\r\n                        }\r\n                        // Move matched elements from seed to results to keep them synchronized\r\n                        i = matcherOut.length;\r\n                        while (i--) {\r\n                            if ((elem = matcherOut[i]) &&\r\n                                (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\r\n                                seed[temp] = !(results[temp] = elem);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    matcherOut = condense(matcherOut === results ?\r\n                        matcherOut.splice(preexisting, matcherOut.length) :\r\n                        matcherOut);\r\n                    if (postFinder) {\r\n                        postFinder(null, results, matcherOut, xml);\r\n                    }\r\n                    else {\r\n                        push.apply(results, matcherOut);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        function matcherFromTokens(tokens) {\r\n            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[\" \"], i = leadingRelative ? 1 : 0, \r\n            // The foundational matcher ensures that elements are reachable from top-level context(s)\r\n            matchContext = addCombinator(function (elem) {\r\n                return elem === checkContext;\r\n            }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {\r\n                return indexOf(checkContext, elem) > -1;\r\n            }, implicitRelative, true), matchers = [function (elem, context, xml) {\r\n                    var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ?\r\n                        matchContext(elem, context, xml) :\r\n                        matchAnyContext(elem, context, xml));\r\n                    // Avoid hanging onto element (issue #299)\r\n                    checkContext = null;\r\n                    return ret;\r\n                }];\r\n            for (; i < len; i++) {\r\n                if ((matcher = Expr.relative[tokens[i].type])) {\r\n                    matchers = [addCombinator(elementMatcher(matchers), matcher)];\r\n                }\r\n                else {\r\n                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\r\n                    // Return special upon seeing a positional matcher\r\n                    if (matcher[expando]) {\r\n                        // Find the next relative operator (if any) for proper handling\r\n                        j = ++i;\r\n                        for (; j < len; j++) {\r\n                            if (Expr.relative[tokens[j].type]) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\r\n                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`\r\n                        tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === \" \" ? \"*\" : \"\" })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));\r\n                    }\r\n                    matchers.push(matcher);\r\n                }\r\n            }\r\n            return elementMatcher(matchers);\r\n        }\r\n        function matcherFromGroupMatchers(elementMatchers, setMatchers) {\r\n            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {\r\n                var elem, j, matcher, matchedCount = 0, i = \"0\", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, \r\n                // We must always have either seed elements or outermost context\r\n                elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost), \r\n                // Use integer dirruns iff this is the outermost matcher\r\n                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1), len = elems.length;\r\n                if (outermost) {\r\n                    outermostContext = context === document || context || outermost;\r\n                }\r\n                // Add elements passing elementMatchers directly to results\r\n                // Support: IE<9, Safari\r\n                // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\r\n                for (; i !== len && (elem = elems[i]) != null; i++) {\r\n                    if (byElement && elem) {\r\n                        j = 0;\r\n                        if (!context && elem.ownerDocument !== document) {\r\n                            setDocument(elem);\r\n                            xml = !documentIsHTML;\r\n                        }\r\n                        while ((matcher = elementMatchers[j++])) {\r\n                            if (matcher(elem, context || document, xml)) {\r\n                                results.push(elem);\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (outermost) {\r\n                            dirruns = dirrunsUnique;\r\n                        }\r\n                    }\r\n                    // Track unmatched elements for set filters\r\n                    if (bySet) {\r\n                        // They will have gone through all possible matchers\r\n                        if ((elem = !matcher && elem)) {\r\n                            matchedCount--;\r\n                        }\r\n                        // Lengthen the array for every element, matched or not\r\n                        if (seed) {\r\n                            unmatched.push(elem);\r\n                        }\r\n                    }\r\n                }\r\n                // `i` is now the count of elements visited above, and adding it to `matchedCount`\r\n                // makes the latter nonnegative.\r\n                matchedCount += i;\r\n                // Apply set filters to unmatched elements\r\n                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\r\n                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\r\n                // no element matchers and no seed.\r\n                // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\r\n                // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\r\n                // numerically zero.\r\n                if (bySet && i !== matchedCount) {\r\n                    j = 0;\r\n                    while ((matcher = setMatchers[j++])) {\r\n                        matcher(unmatched, setMatched, context, xml);\r\n                    }\r\n                    if (seed) {\r\n                        // Reintegrate element matches to eliminate the need for sorting\r\n                        if (matchedCount > 0) {\r\n                            while (i--) {\r\n                                if (!(unmatched[i] || setMatched[i])) {\r\n                                    setMatched[i] = pop.call(results);\r\n                                }\r\n                            }\r\n                        }\r\n                        // Discard index placeholder values to get only actual matches\r\n                        setMatched = condense(setMatched);\r\n                    }\r\n                    // Add matches to results\r\n                    push.apply(results, setMatched);\r\n                    // Seedless set matches succeeding multiple successful matchers stipulate sorting\r\n                    if (outermost && !seed && setMatched.length > 0 &&\r\n                        (matchedCount + setMatchers.length) > 1) {\r\n                        Sizzle.uniqueSort(results);\r\n                    }\r\n                }\r\n                // Override manipulation of globals by nested matchers\r\n                if (outermost) {\r\n                    dirruns = dirrunsUnique;\r\n                    outermostContext = contextBackup;\r\n                }\r\n                return unmatched;\r\n            };\r\n            return bySet ?\r\n                markFunction(superMatcher) :\r\n                superMatcher;\r\n        }\r\n        compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\r\n            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + \" \"];\r\n            if (!cached) {\r\n                // Generate a function of recursive functions that can be used to check each element\r\n                if (!match) {\r\n                    match = tokenize(selector);\r\n                }\r\n                i = match.length;\r\n                while (i--) {\r\n                    cached = matcherFromTokens(match[i]);\r\n                    if (cached[expando]) {\r\n                        setMatchers.push(cached);\r\n                    }\r\n                    else {\r\n                        elementMatchers.push(cached);\r\n                    }\r\n                }\r\n                // Cache the compiled function\r\n                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\r\n                // Save selector and tokenization\r\n                cached.selector = selector;\r\n            }\r\n            return cached;\r\n        };\r\n        /**\r\n         * A low-level selection function that works with Sizzle's compiled\r\n         *  selector functions\r\n         * @param {String|Function} selector A selector or a pre-compiled\r\n         *  selector function built with Sizzle.compile\r\n         * @param {Element} context\r\n         * @param {Array} [results]\r\n         * @param {Array} [seed] A set of elements to match against\r\n         */\r\n        select = Sizzle.select = function (selector, context, results, seed) {\r\n            var i, tokens, token, type, find, compiled = typeof selector === \"function\" && selector, match = !seed && tokenize((selector = compiled.selector || selector));\r\n            results = results || [];\r\n            // Try to minimize operations if there is only one selector in the list and no seed\r\n            // (the latter of which guarantees us context)\r\n            if (match.length === 1) {\r\n                // Reduce context if the leading compound selector is an ID\r\n                tokens = match[0] = match[0].slice(0);\r\n                if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\r\n                    context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\r\n                    context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\r\n                    if (!context) {\r\n                        return results;\r\n                    }\r\n                    else if (compiled) {\r\n                        context = context.parentNode;\r\n                    }\r\n                    selector = selector.slice(tokens.shift().value.length);\r\n                }\r\n                // Fetch a seed set for right-to-left matching\r\n                i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\r\n                while (i--) {\r\n                    token = tokens[i];\r\n                    // Abort if we hit a combinator\r\n                    if (Expr.relative[(type = token.type)]) {\r\n                        break;\r\n                    }\r\n                    if ((find = Expr.find[type])) {\r\n                        // Search, expanding context for leading sibling combinators\r\n                        if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {\r\n                            // If seed is empty or no tokens remain, we can return early\r\n                            tokens.splice(i, 1);\r\n                            selector = seed.length && toSelector(tokens);\r\n                            if (!selector) {\r\n                                push.apply(results, seed);\r\n                                return results;\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Compile and execute a filtering function if one is not provided\r\n            // Provide `match` to avoid retokenization if we modified the selector above\r\n            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\r\n            return results;\r\n        };\r\n        // One-time assignments\r\n        // Sort stability\r\n        support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\r\n        // Support: Chrome 14-35+\r\n        // Always assume duplicates if they aren't passed to the comparison function\r\n        support.detectDuplicates = !!hasDuplicate;\r\n        // Initialize against the default document\r\n        setDocument();\r\n        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\r\n        // Detached nodes confoundingly follow *each other*\r\n        support.sortDetached = assert(function (el) {\r\n            // Should return 1, but returns 4 (following)\r\n            return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\r\n        });\r\n        // Support: IE<8\r\n        // Prevent attribute/property \"interpolation\"\r\n        // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\r\n        if (!assert(function (el) {\r\n            el.innerHTML = \"<a href='#'></a>\";\r\n            return el.firstChild.getAttribute(\"href\") === \"#\";\r\n        })) {\r\n            addHandle(\"type|href|height|width\", function (elem, name, isXML) {\r\n                if (!isXML) {\r\n                    return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\r\n                }\r\n            });\r\n        }\r\n        // Support: IE<9\r\n        // Use defaultValue in place of getAttribute(\"value\")\r\n        if (!support.attributes || !assert(function (el) {\r\n            el.innerHTML = \"<input/>\";\r\n            el.firstChild.setAttribute(\"value\", \"\");\r\n            return el.firstChild.getAttribute(\"value\") === \"\";\r\n        })) {\r\n            addHandle(\"value\", function (elem, name, isXML) {\r\n                if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\r\n                    return elem.defaultValue;\r\n                }\r\n            });\r\n        }\r\n        // Support: IE<9\r\n        // Use getAttributeNode to fetch booleans when getAttribute lies\r\n        if (!assert(function (el) {\r\n            return el.getAttribute(\"disabled\") == null;\r\n        })) {\r\n            addHandle(booleans, function (elem, name, isXML) {\r\n                var val;\r\n                if (!isXML) {\r\n                    return elem[name] === true ? name.toLowerCase() :\r\n                        (val = elem.getAttributeNode(name)) && val.specified ?\r\n                            val.value :\r\n                            null;\r\n                }\r\n            });\r\n        }\r\n        return Sizzle;\r\n    })(window);\r\n    jQuery.find = Sizzle;\r\n    jQuery.expr = Sizzle.selectors;\r\n    // Deprecated\r\n    jQuery.expr[\":\"] = jQuery.expr.pseudos;\r\n    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\r\n    jQuery.text = Sizzle.getText;\r\n    jQuery.isXMLDoc = Sizzle.isXML;\r\n    jQuery.contains = Sizzle.contains;\r\n    jQuery.escapeSelector = Sizzle.escape;\r\n    var dir = function (elem, dir, until) {\r\n        var matched = [], truncate = until !== undefined;\r\n        while ((elem = elem[dir]) && elem.nodeType !== 9) {\r\n            if (elem.nodeType === 1) {\r\n                if (truncate && jQuery(elem).is(until)) {\r\n                    break;\r\n                }\r\n                matched.push(elem);\r\n            }\r\n        }\r\n        return matched;\r\n    };\r\n    var siblings = function (n, elem) {\r\n        var matched = [];\r\n        for (; n; n = n.nextSibling) {\r\n            if (n.nodeType === 1 && n !== elem) {\r\n                matched.push(n);\r\n            }\r\n        }\r\n        return matched;\r\n    };\r\n    var rneedsContext = jQuery.expr.match.needsContext;\r\n    var rsingleTag = (/^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i);\r\n    var risSimple = /^.[^:#\\[\\.,]*$/;\r\n    // Implement the identical functionality for filter and not\r\n    function winnow(elements, qualifier, not) {\r\n        if (jQuery.isFunction(qualifier)) {\r\n            return jQuery.grep(elements, function (elem, i) {\r\n                return !!qualifier.call(elem, i, elem) !== not;\r\n            });\r\n        }\r\n        // Single element\r\n        if (qualifier.nodeType) {\r\n            return jQuery.grep(elements, function (elem) {\r\n                return (elem === qualifier) !== not;\r\n            });\r\n        }\r\n        // Arraylike of elements (jQuery, arguments, Array)\r\n        if (typeof qualifier !== \"string\") {\r\n            return jQuery.grep(elements, function (elem) {\r\n                return (indexOf.call(qualifier, elem) > -1) !== not;\r\n            });\r\n        }\r\n        // Simple selector that can be filtered directly, removing non-Elements\r\n        if (risSimple.test(qualifier)) {\r\n            return jQuery.filter(qualifier, elements, not);\r\n        }\r\n        // Complex selector, compare the two sets, removing non-Elements\r\n        qualifier = jQuery.filter(qualifier, elements);\r\n        return jQuery.grep(elements, function (elem) {\r\n            return (indexOf.call(qualifier, elem) > -1) !== not && elem.nodeType === 1;\r\n        });\r\n    }\r\n    jQuery.filter = function (expr, elems, not) {\r\n        var elem = elems[0];\r\n        if (not) {\r\n            expr = \":not(\" + expr + \")\";\r\n        }\r\n        if (elems.length === 1 && elem.nodeType === 1) {\r\n            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\r\n        }\r\n        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\r\n            return elem.nodeType === 1;\r\n        }));\r\n    };\r\n    jQuery.fn.extend({\r\n        find: function (selector) {\r\n            var i, ret, len = this.length, self = this;\r\n            if (typeof selector !== \"string\") {\r\n                return this.pushStack(jQuery(selector).filter(function () {\r\n                    for (i = 0; i < len; i++) {\r\n                        if (jQuery.contains(self[i], this)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n            ret = this.pushStack([]);\r\n            for (i = 0; i < len; i++) {\r\n                jQuery.find(selector, self[i], ret);\r\n            }\r\n            return len > 1 ? jQuery.uniqueSort(ret) : ret;\r\n        },\r\n        filter: function (selector) {\r\n            return this.pushStack(winnow(this, selector || [], false));\r\n        },\r\n        not: function (selector) {\r\n            return this.pushStack(winnow(this, selector || [], true));\r\n        },\r\n        is: function (selector) {\r\n            return !!winnow(this, \r\n            // If this is a positional/relative selector, check membership in the returned set\r\n            // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\r\n            typeof selector === \"string\" && rneedsContext.test(selector) ?\r\n                jQuery(selector) :\r\n                selector || [], false).length;\r\n        }\r\n    });\r\n    // Initialize a jQuery object\r\n    // A central reference to the root jQuery(document)\r\n    var rootjQuery, \r\n    // A simple way to check for HTML strings\r\n    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\r\n    // Strict HTML recognition (#11290: must start with <)\r\n    // Shortcut simple #id case for speed\r\n    rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/, init = jQuery.fn.init = function (selector, context, root) {\r\n        var match, elem;\r\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\r\n        if (!selector) {\r\n            return this;\r\n        }\r\n        // Method init() accepts an alternate rootjQuery\r\n        // so migrate can support jQuery.sub (gh-2101)\r\n        root = root || rootjQuery;\r\n        // Handle HTML strings\r\n        if (typeof selector === \"string\") {\r\n            if (selector[0] === \"<\" &&\r\n                selector[selector.length - 1] === \">\" &&\r\n                selector.length >= 3) {\r\n                // Assume that strings that start and end with <> are HTML and skip the regex check\r\n                match = [null, selector, null];\r\n            }\r\n            else {\r\n                match = rquickExpr.exec(selector);\r\n            }\r\n            // Match html or make sure no context is specified for #id\r\n            if (match && (match[1] || !context)) {\r\n                // HANDLE: $(html) -> $(array)\r\n                if (match[1]) {\r\n                    context = context instanceof jQuery ? context[0] : context;\r\n                    // Option to run scripts is true for back-compat\r\n                    // Intentionally let the error be thrown if parseHTML is not present\r\n                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\r\n                    // HANDLE: $(html, props)\r\n                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\r\n                        for (match in context) {\r\n                            // Properties of context are called as methods if possible\r\n                            if (jQuery.isFunction(this[match])) {\r\n                                this[match](context[match]);\r\n                            }\r\n                            else {\r\n                                this.attr(match, context[match]);\r\n                            }\r\n                        }\r\n                    }\r\n                    return this;\r\n                }\r\n                else {\r\n                    elem = document.getElementById(match[2]);\r\n                    if (elem) {\r\n                        // Inject the element directly into the jQuery object\r\n                        this[0] = elem;\r\n                        this.length = 1;\r\n                    }\r\n                    return this;\r\n                }\r\n            }\r\n            else if (!context || context.jquery) {\r\n                return (context || root).find(selector);\r\n            }\r\n            else {\r\n                return this.constructor(context).find(selector);\r\n            }\r\n        }\r\n        else if (selector.nodeType) {\r\n            this[0] = selector;\r\n            this.length = 1;\r\n            return this;\r\n        }\r\n        else if (jQuery.isFunction(selector)) {\r\n            return root.ready !== undefined ?\r\n                root.ready(selector) :\r\n                // Execute immediately if ready is not present\r\n                selector(jQuery);\r\n        }\r\n        return jQuery.makeArray(selector, this);\r\n    };\r\n    // Give the init function the jQuery prototype for later instantiation\r\n    init.prototype = jQuery.fn;\r\n    // Initialize central reference\r\n    rootjQuery = jQuery(document);\r\n    var rparentsprev = /^(?:parents|prev(?:Until|All))/, \r\n    // Methods guaranteed to produce a unique set when starting from a unique set\r\n    guaranteedUnique = {\r\n        children: true,\r\n        contents: true,\r\n        next: true,\r\n        prev: true\r\n    };\r\n    jQuery.fn.extend({\r\n        has: function (target) {\r\n            var targets = jQuery(target, this), l = targets.length;\r\n            return this.filter(function () {\r\n                var i = 0;\r\n                for (; i < l; i++) {\r\n                    if (jQuery.contains(this, targets[i])) {\r\n                        return true;\r\n                    }\r\n                }\r\n            });\r\n        },\r\n        closest: function (selectors, context) {\r\n            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== \"string\" && jQuery(selectors);\r\n            // Positional selectors never match, since there's no _selection_ context\r\n            if (!rneedsContext.test(selectors)) {\r\n                for (; i < l; i++) {\r\n                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\r\n                        // Always skip document fragments\r\n                        if (cur.nodeType < 11 && (targets ?\r\n                            targets.index(cur) > -1 :\r\n                            // Don't pass non-elements to Sizzle\r\n                            cur.nodeType === 1 &&\r\n                                jQuery.find.matchesSelector(cur, selectors))) {\r\n                            matched.push(cur);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\r\n        },\r\n        // Determine the position of an element within the set\r\n        index: function (elem) {\r\n            // No argument, return index in parent\r\n            if (!elem) {\r\n                return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;\r\n            }\r\n            // Index in selector\r\n            if (typeof elem === \"string\") {\r\n                return indexOf.call(jQuery(elem), this[0]);\r\n            }\r\n            // Locate the position of the desired element\r\n            return indexOf.call(this, \r\n            // If it receives a jQuery object, the first element is used\r\n            elem.jquery ? elem[0] : elem);\r\n        },\r\n        add: function (selector, context) {\r\n            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\r\n        },\r\n        addBack: function (selector) {\r\n            return this.add(selector == null ?\r\n                this.prevObject : this.prevObject.filter(selector));\r\n        }\r\n    });\r\n    function sibling(cur, dir) {\r\n        while ((cur = cur[dir]) && cur.nodeType !== 1) { }\r\n        return cur;\r\n    }\r\n    jQuery.each({\r\n        parent: function (elem) {\r\n            var parent = elem.parentNode;\r\n            return parent && parent.nodeType !== 11 ? parent : null;\r\n        },\r\n        parents: function (elem) {\r\n            return dir(elem, \"parentNode\");\r\n        },\r\n        parentsUntil: function (elem, i, until) {\r\n            return dir(elem, \"parentNode\", until);\r\n        },\r\n        next: function (elem) {\r\n            return sibling(elem, \"nextSibling\");\r\n        },\r\n        prev: function (elem) {\r\n            return sibling(elem, \"previousSibling\");\r\n        },\r\n        nextAll: function (elem) {\r\n            return dir(elem, \"nextSibling\");\r\n        },\r\n        prevAll: function (elem) {\r\n            return dir(elem, \"previousSibling\");\r\n        },\r\n        nextUntil: function (elem, i, until) {\r\n            return dir(elem, \"nextSibling\", until);\r\n        },\r\n        prevUntil: function (elem, i, until) {\r\n            return dir(elem, \"previousSibling\", until);\r\n        },\r\n        siblings: function (elem) {\r\n            return siblings((elem.parentNode || {}).firstChild, elem);\r\n        },\r\n        children: function (elem) {\r\n            return siblings(elem.firstChild);\r\n        },\r\n        contents: function (elem) {\r\n            return elem.contentDocument || jQuery.merge([], elem.childNodes);\r\n        }\r\n    }, function (name, fn) {\r\n        jQuery.fn[name] = function (until, selector) {\r\n            var matched = jQuery.map(this, fn, until);\r\n            if (name.slice(-5) !== \"Until\") {\r\n                selector = until;\r\n            }\r\n            if (selector && typeof selector === \"string\") {\r\n                matched = jQuery.filter(selector, matched);\r\n            }\r\n            if (this.length > 1) {\r\n                // Remove duplicates\r\n                if (!guaranteedUnique[name]) {\r\n                    jQuery.uniqueSort(matched);\r\n                }\r\n                // Reverse order for parents* and prev-derivatives\r\n                if (rparentsprev.test(name)) {\r\n                    matched.reverse();\r\n                }\r\n            }\r\n            return this.pushStack(matched);\r\n        };\r\n    });\r\n    var rnothtmlwhite = (/[^\\x20\\t\\r\\n\\f]+/g);\r\n    // Convert String-formatted options into Object-formatted ones\r\n    function createOptions(options) {\r\n        var object = {};\r\n        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\r\n            object[flag] = true;\r\n        });\r\n        return object;\r\n    }\r\n    /*\r\n     * Create a callback list using the following parameters:\r\n     *\r\n     *\toptions: an optional list of space-separated options that will change how\r\n     *\t\t\tthe callback list behaves or a more traditional option object\r\n     *\r\n     * By default a callback list will act like an event callback list and can be\r\n     * \"fired\" multiple times.\r\n     *\r\n     * Possible options:\r\n     *\r\n     *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\r\n     *\r\n     *\tmemory:\t\t\twill keep track of previous values and will call any callback added\r\n     *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\r\n     *\t\t\t\t\tvalues (like a Deferred)\r\n     *\r\n     *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\r\n     *\r\n     *\tstopOnFalse:\tinterrupt callings when a callback returns false\r\n     *\r\n     */\r\n    jQuery.Callbacks = function (options) {\r\n        // Convert options from String-formatted to Object-formatted if needed\r\n        // (we check in cache first)\r\n        options = typeof options === \"string\" ?\r\n            createOptions(options) :\r\n            jQuery.extend({}, options);\r\n        var // Flag to know if list is currently firing\r\n        firing, \r\n        // Last fire value for non-forgettable lists\r\n        memory, \r\n        // Flag to know if list was already fired\r\n        fired, \r\n        // Flag to prevent firing\r\n        locked, \r\n        // Actual callback list\r\n        list = [], \r\n        // Queue of execution data for repeatable lists\r\n        queue = [], \r\n        // Index of currently firing callback (modified by add/remove as needed)\r\n        firingIndex = -1, \r\n        // Fire callbacks\r\n        fire = function () {\r\n            // Enforce single-firing\r\n            locked = options.once;\r\n            // Execute callbacks for all pending executions,\r\n            // respecting firingIndex overrides and runtime changes\r\n            fired = firing = true;\r\n            for (; queue.length; firingIndex = -1) {\r\n                memory = queue.shift();\r\n                while (++firingIndex < list.length) {\r\n                    // Run callback and check for early termination\r\n                    if (list[firingIndex].apply(memory[0], memory[1]) === false &&\r\n                        options.stopOnFalse) {\r\n                        // Jump to end and forget the data so .add doesn't re-fire\r\n                        firingIndex = list.length;\r\n                        memory = false;\r\n                    }\r\n                }\r\n            }\r\n            // Forget the data if we're done with it\r\n            if (!options.memory) {\r\n                memory = false;\r\n            }\r\n            firing = false;\r\n            // Clean up if we're done firing for good\r\n            if (locked) {\r\n                // Keep an empty list if we have data for future add calls\r\n                if (memory) {\r\n                    list = [];\r\n                }\r\n                else {\r\n                    list = \"\";\r\n                }\r\n            }\r\n        }, \r\n        // Actual Callbacks object\r\n        self = {\r\n            // Add a callback or a collection of callbacks to the list\r\n            add: function () {\r\n                if (list) {\r\n                    // If we have memory from a past run, we should fire after adding\r\n                    if (memory && !firing) {\r\n                        firingIndex = list.length - 1;\r\n                        queue.push(memory);\r\n                    }\r\n                    (function add(args) {\r\n                        jQuery.each(args, function (_, arg) {\r\n                            if (jQuery.isFunction(arg)) {\r\n                                if (!options.unique || !self.has(arg)) {\r\n                                    list.push(arg);\r\n                                }\r\n                            }\r\n                            else if (arg && arg.length && jQuery.type(arg) !== \"string\") {\r\n                                // Inspect recursively\r\n                                add(arg);\r\n                            }\r\n                        });\r\n                    })(arguments);\r\n                    if (memory && !firing) {\r\n                        fire();\r\n                    }\r\n                }\r\n                return this;\r\n            },\r\n            // Remove a callback from the list\r\n            remove: function () {\r\n                jQuery.each(arguments, function (_, arg) {\r\n                    var index;\r\n                    while ((index = jQuery.inArray(arg, list, index)) > -1) {\r\n                        list.splice(index, 1);\r\n                        // Handle firing indexes\r\n                        if (index <= firingIndex) {\r\n                            firingIndex--;\r\n                        }\r\n                    }\r\n                });\r\n                return this;\r\n            },\r\n            // Check if a given callback is in the list.\r\n            // If no argument is given, return whether or not list has callbacks attached.\r\n            has: function (fn) {\r\n                return fn ?\r\n                    jQuery.inArray(fn, list) > -1 :\r\n                    list.length > 0;\r\n            },\r\n            // Remove all callbacks from the list\r\n            empty: function () {\r\n                if (list) {\r\n                    list = [];\r\n                }\r\n                return this;\r\n            },\r\n            // Disable .fire and .add\r\n            // Abort any current/pending executions\r\n            // Clear all callbacks and values\r\n            disable: function () {\r\n                locked = queue = [];\r\n                list = memory = \"\";\r\n                return this;\r\n            },\r\n            disabled: function () {\r\n                return !list;\r\n            },\r\n            // Disable .fire\r\n            // Also disable .add unless we have memory (since it would have no effect)\r\n            // Abort any pending executions\r\n            lock: function () {\r\n                locked = queue = [];\r\n                if (!memory && !firing) {\r\n                    list = memory = \"\";\r\n                }\r\n                return this;\r\n            },\r\n            locked: function () {\r\n                return !!locked;\r\n            },\r\n            // Call all callbacks with the given context and arguments\r\n            fireWith: function (context, args) {\r\n                if (!locked) {\r\n                    args = args || [];\r\n                    args = [context, args.slice ? args.slice() : args];\r\n                    queue.push(args);\r\n                    if (!firing) {\r\n                        fire();\r\n                    }\r\n                }\r\n                return this;\r\n            },\r\n            // Call all the callbacks with the given arguments\r\n            fire: function () {\r\n                self.fireWith(this, arguments);\r\n                return this;\r\n            },\r\n            // To know if the callbacks have already been called at least once\r\n            fired: function () {\r\n                return !!fired;\r\n            }\r\n        };\r\n        return self;\r\n    };\r\n    function Identity(v) {\r\n        return v;\r\n    }\r\n    function Thrower(ex) {\r\n        throw ex;\r\n    }\r\n    function adoptValue(value, resolve, reject) {\r\n        var method;\r\n        try {\r\n            // Check for promise aspect first to privilege synchronous behavior\r\n            if (value && jQuery.isFunction((method = value.promise))) {\r\n                method.call(value).done(resolve).fail(reject);\r\n            }\r\n            else if (value && jQuery.isFunction((method = value.then))) {\r\n                method.call(value, resolve, reject);\r\n            }\r\n            else {\r\n                // Support: Android 4.0 only\r\n                // Strict mode functions invoked without .call/.apply get global-object context\r\n                resolve.call(undefined, value);\r\n            }\r\n        }\r\n        catch (value) {\r\n            // Support: Android 4.0 only\r\n            // Strict mode functions invoked without .call/.apply get global-object context\r\n            reject.call(undefined, value);\r\n        }\r\n    }\r\n    jQuery.extend({\r\n        Deferred: function (func) {\r\n            var tuples = [\r\n                // action, add listener, callbacks,\r\n                // ... .then handlers, argument index, [final state]\r\n                [\"notify\", \"progress\", jQuery.Callbacks(\"memory\"),\r\n                    jQuery.Callbacks(\"memory\"), 2],\r\n                [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"),\r\n                    jQuery.Callbacks(\"once memory\"), 0, \"resolved\"],\r\n                [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"),\r\n                    jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]\r\n            ], state = \"pending\", promise = {\r\n                state: function () {\r\n                    return state;\r\n                },\r\n                always: function () {\r\n                    deferred.done(arguments).fail(arguments);\r\n                    return this;\r\n                },\r\n                \"catch\": function (fn) {\r\n                    return promise.then(null, fn);\r\n                },\r\n                // Keep pipe for back-compat\r\n                pipe: function () {\r\n                    var fns = arguments;\r\n                    return jQuery.Deferred(function (newDefer) {\r\n                        jQuery.each(tuples, function (i, tuple) {\r\n                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)\r\n                            var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];\r\n                            // deferred.progress(function() { bind to newDefer or newDefer.notify })\r\n                            // deferred.done(function() { bind to newDefer or newDefer.resolve })\r\n                            // deferred.fail(function() { bind to newDefer or newDefer.reject })\r\n                            deferred[tuple[1]](function () {\r\n                                var returned = fn && fn.apply(this, arguments);\r\n                                if (returned && jQuery.isFunction(returned.promise)) {\r\n                                    returned.promise()\r\n                                        .progress(newDefer.notify)\r\n                                        .done(newDefer.resolve)\r\n                                        .fail(newDefer.reject);\r\n                                }\r\n                                else {\r\n                                    newDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\r\n                                }\r\n                            });\r\n                        });\r\n                        fns = null;\r\n                    }).promise();\r\n                },\r\n                then: function (onFulfilled, onRejected, onProgress) {\r\n                    var maxDepth = 0;\r\n                    function resolve(depth, deferred, handler, special) {\r\n                        return function () {\r\n                            var that = this, args = arguments, mightThrow = function () {\r\n                                var returned, then;\r\n                                // Support: Promises/A+ section 2.3.3.3.3\r\n                                // https://promisesaplus.com/#point-59\r\n                                // Ignore double-resolution attempts\r\n                                if (depth < maxDepth) {\r\n                                    return;\r\n                                }\r\n                                returned = handler.apply(that, args);\r\n                                // Support: Promises/A+ section 2.3.1\r\n                                // https://promisesaplus.com/#point-48\r\n                                if (returned === deferred.promise()) {\r\n                                    throw new TypeError(\"Thenable self-resolution\");\r\n                                }\r\n                                // Support: Promises/A+ sections 2.3.3.1, 3.5\r\n                                // https://promisesaplus.com/#point-54\r\n                                // https://promisesaplus.com/#point-75\r\n                                // Retrieve `then` only once\r\n                                then = returned &&\r\n                                    // Support: Promises/A+ section 2.3.4\r\n                                    // https://promisesaplus.com/#point-64\r\n                                    // Only check objects and functions for thenability\r\n                                    (typeof returned === \"object\" ||\r\n                                        typeof returned === \"function\") &&\r\n                                    returned.then;\r\n                                // Handle a returned thenable\r\n                                if (jQuery.isFunction(then)) {\r\n                                    // Special processors (notify) just wait for resolution\r\n                                    if (special) {\r\n                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));\r\n                                    }\r\n                                    else {\r\n                                        // ...and disregard older resolution values\r\n                                        maxDepth++;\r\n                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    // Only substitute handlers pass on context\r\n                                    // and multiple values (non-spec behavior)\r\n                                    if (handler !== Identity) {\r\n                                        that = undefined;\r\n                                        args = [returned];\r\n                                    }\r\n                                    // Process the value(s)\r\n                                    // Default process is resolve\r\n                                    (special || deferred.resolveWith)(that, args);\r\n                                }\r\n                            }, \r\n                            // Only normal processors (resolve) catch and reject exceptions\r\n                            process = special ?\r\n                                mightThrow :\r\n                                function () {\r\n                                    try {\r\n                                        mightThrow();\r\n                                    }\r\n                                    catch (e) {\r\n                                        if (jQuery.Deferred.exceptionHook) {\r\n                                            jQuery.Deferred.exceptionHook(e, process.stackTrace);\r\n                                        }\r\n                                        // Support: Promises/A+ section 2.3.3.3.4.1\r\n                                        // https://promisesaplus.com/#point-61\r\n                                        // Ignore post-resolution exceptions\r\n                                        if (depth + 1 >= maxDepth) {\r\n                                            // Only substitute handlers pass on context\r\n                                            // and multiple values (non-spec behavior)\r\n                                            if (handler !== Thrower) {\r\n                                                that = undefined;\r\n                                                args = [e];\r\n                                            }\r\n                                            deferred.rejectWith(that, args);\r\n                                        }\r\n                                    }\r\n                                };\r\n                            // Support: Promises/A+ section 2.3.3.3.1\r\n                            // https://promisesaplus.com/#point-57\r\n                            // Re-resolve promises immediately to dodge false rejection from\r\n                            // subsequent errors\r\n                            if (depth) {\r\n                                process();\r\n                            }\r\n                            else {\r\n                                // Call an optional hook to record the stack, in case of exception\r\n                                // since it's otherwise lost when execution goes async\r\n                                if (jQuery.Deferred.getStackHook) {\r\n                                    process.stackTrace = jQuery.Deferred.getStackHook();\r\n                                }\r\n                                window.setTimeout(process);\r\n                            }\r\n                        };\r\n                    }\r\n                    return jQuery.Deferred(function (newDefer) {\r\n                        // progress_handlers.add( ... )\r\n                        tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ?\r\n                            onProgress :\r\n                            Identity, newDefer.notifyWith));\r\n                        // fulfilled_handlers.add( ... )\r\n                        tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ?\r\n                            onFulfilled :\r\n                            Identity));\r\n                        // rejected_handlers.add( ... )\r\n                        tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ?\r\n                            onRejected :\r\n                            Thrower));\r\n                    }).promise();\r\n                },\r\n                // Get a promise for this deferred\r\n                // If obj is provided, the promise aspect is added to the object\r\n                promise: function (obj) {\r\n                    return obj != null ? jQuery.extend(obj, promise) : promise;\r\n                }\r\n            }, deferred = {};\r\n            // Add list-specific methods\r\n            jQuery.each(tuples, function (i, tuple) {\r\n                var list = tuple[2], stateString = tuple[5];\r\n                // promise.progress = list.add\r\n                // promise.done = list.add\r\n                // promise.fail = list.add\r\n                promise[tuple[1]] = list.add;\r\n                // Handle state\r\n                if (stateString) {\r\n                    list.add(function () {\r\n                        // state = \"resolved\" (i.e., fulfilled)\r\n                        // state = \"rejected\"\r\n                        state = stateString;\r\n                    }, \r\n                    // rejected_callbacks.disable\r\n                    // fulfilled_callbacks.disable\r\n                    tuples[3 - i][2].disable, \r\n                    // progress_callbacks.lock\r\n                    tuples[0][2].lock);\r\n                }\r\n                // progress_handlers.fire\r\n                // fulfilled_handlers.fire\r\n                // rejected_handlers.fire\r\n                list.add(tuple[3].fire);\r\n                // deferred.notify = function() { deferred.notifyWith(...) }\r\n                // deferred.resolve = function() { deferred.resolveWith(...) }\r\n                // deferred.reject = function() { deferred.rejectWith(...) }\r\n                deferred[tuple[0]] = function () {\r\n                    deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\r\n                    return this;\r\n                };\r\n                // deferred.notifyWith = list.fireWith\r\n                // deferred.resolveWith = list.fireWith\r\n                // deferred.rejectWith = list.fireWith\r\n                deferred[tuple[0] + \"With\"] = list.fireWith;\r\n            });\r\n            // Make the deferred a promise\r\n            promise.promise(deferred);\r\n            // Call given func if any\r\n            if (func) {\r\n                func.call(deferred, deferred);\r\n            }\r\n            // All done!\r\n            return deferred;\r\n        },\r\n        // Deferred helper\r\n        when: function (singleValue) {\r\n            var \r\n            // count of uncompleted subordinates\r\n            remaining = arguments.length, \r\n            // count of unprocessed arguments\r\n            i = remaining, \r\n            // subordinate fulfillment data\r\n            resolveContexts = Array(i), resolveValues = slice.call(arguments), \r\n            // the master Deferred\r\n            master = jQuery.Deferred(), \r\n            // subordinate callback factory\r\n            updateFunc = function (i) {\r\n                return function (value) {\r\n                    resolveContexts[i] = this;\r\n                    resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;\r\n                    if (!(--remaining)) {\r\n                        master.resolveWith(resolveContexts, resolveValues);\r\n                    }\r\n                };\r\n            };\r\n            // Single- and empty arguments are adopted like Promise.resolve\r\n            if (remaining <= 1) {\r\n                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject);\r\n                // Use .then() to unwrap secondary thenables (cf. gh-3000)\r\n                if (master.state() === \"pending\" ||\r\n                    jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {\r\n                    return master.then();\r\n                }\r\n            }\r\n            // Multiple arguments are aggregated like Promise.all array elements\r\n            while (i--) {\r\n                adoptValue(resolveValues[i], updateFunc(i), master.reject);\r\n            }\r\n            return master.promise();\r\n        }\r\n    });\r\n    // These usually indicate a programmer mistake during development,\r\n    // warn about them ASAP rather than swallowing them by default.\r\n    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\r\n    jQuery.Deferred.exceptionHook = function (error, stack) {\r\n        // Support: IE 8 - 9 only\r\n        // Console exists when dev tools are open, which can happen at any time\r\n        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\r\n            window.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, stack);\r\n        }\r\n    };\r\n    jQuery.readyException = function (error) {\r\n        window.setTimeout(function () {\r\n            throw error;\r\n        });\r\n    };\r\n    // The deferred used on DOM ready\r\n    var readyList = jQuery.Deferred();\r\n    jQuery.fn.ready = function (fn) {\r\n        readyList\r\n            .then(fn)\r\n            .catch(function (error) {\r\n            jQuery.readyException(error);\r\n        });\r\n        return this;\r\n    };\r\n    jQuery.extend({\r\n        // Is the DOM ready to be used? Set to true once it occurs.\r\n        isReady: false,\r\n        // A counter to track how many items to wait for before\r\n        // the ready event fires. See #6781\r\n        readyWait: 1,\r\n        // Hold (or release) the ready event\r\n        holdReady: function (hold) {\r\n            if (hold) {\r\n                jQuery.readyWait++;\r\n            }\r\n            else {\r\n                jQuery.ready(true);\r\n            }\r\n        },\r\n        // Handle when the DOM is ready\r\n        ready: function (wait) {\r\n            // Abort if there are pending holds or we're already ready\r\n            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\r\n                return;\r\n            }\r\n            // Remember that the DOM is ready\r\n            jQuery.isReady = true;\r\n            // If a normal DOM Ready event fired, decrement, and wait if need be\r\n            if (wait !== true && --jQuery.readyWait > 0) {\r\n                return;\r\n            }\r\n            // If there are functions bound, to execute\r\n            readyList.resolveWith(document, [jQuery]);\r\n        }\r\n    });\r\n    jQuery.ready.then = readyList.then;\r\n    // The ready event handler and self cleanup method\r\n    function completed() {\r\n        document.removeEventListener(\"DOMContentLoaded\", completed);\r\n        window.removeEventListener(\"load\", completed);\r\n        jQuery.ready();\r\n    }\r\n    // Catch cases where $(document).ready() is called\r\n    // after the browser event has already occurred.\r\n    // Support: IE <=9 - 10 only\r\n    // Older IE sometimes signals \"interactive\" too soon\r\n    if (document.readyState === \"complete\" ||\r\n        (document.readyState !== \"loading\" && !document.documentElement.doScroll)) {\r\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\r\n        window.setTimeout(jQuery.ready);\r\n    }\r\n    else {\r\n        // Use the handy event callback\r\n        document.addEventListener(\"DOMContentLoaded\", completed);\r\n        // A fallback to window.onload, that will always work\r\n        window.addEventListener(\"load\", completed);\r\n    }\r\n    // Multifunctional method to get and set values of a collection\r\n    // The value/s can optionally be executed if it's a function\r\n    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {\r\n        var i = 0, len = elems.length, bulk = key == null;\r\n        // Sets many values\r\n        if (jQuery.type(key) === \"object\") {\r\n            chainable = true;\r\n            for (i in key) {\r\n                access(elems, fn, i, key[i], true, emptyGet, raw);\r\n            }\r\n        }\r\n        else if (value !== undefined) {\r\n            chainable = true;\r\n            if (!jQuery.isFunction(value)) {\r\n                raw = true;\r\n            }\r\n            if (bulk) {\r\n                // Bulk operations run against the entire set\r\n                if (raw) {\r\n                    fn.call(elems, value);\r\n                    fn = null;\r\n                }\r\n                else {\r\n                    bulk = fn;\r\n                    fn = function (elem, key, value) {\r\n                        return bulk.call(jQuery(elem), value);\r\n                    };\r\n                }\r\n            }\r\n            if (fn) {\r\n                for (; i < len; i++) {\r\n                    fn(elems[i], key, raw ?\r\n                        value :\r\n                        value.call(elems[i], i, fn(elems[i], key)));\r\n                }\r\n            }\r\n        }\r\n        if (chainable) {\r\n            return elems;\r\n        }\r\n        // Gets\r\n        if (bulk) {\r\n            return fn.call(elems);\r\n        }\r\n        return len ? fn(elems[0], key) : emptyGet;\r\n    };\r\n    var acceptData = function (owner) {\r\n        // Accepts only:\r\n        //  - Node\r\n        //    - Node.ELEMENT_NODE\r\n        //    - Node.DOCUMENT_NODE\r\n        //  - Object\r\n        //    - Any\r\n        return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);\r\n    };\r\n    function Data() {\r\n        this.expando = jQuery.expando + Data.uid++;\r\n    }\r\n    Data.uid = 1;\r\n    Data.prototype = {\r\n        cache: function (owner) {\r\n            // Check if the owner object already has a cache\r\n            var value = owner[this.expando];\r\n            // If not, create one\r\n            if (!value) {\r\n                value = {};\r\n                // We can accept data for non-element nodes in modern browsers,\r\n                // but we should not, see #8335.\r\n                // Always return an empty object.\r\n                if (acceptData(owner)) {\r\n                    // If it is a node unlikely to be stringify-ed or looped over\r\n                    // use plain assignment\r\n                    if (owner.nodeType) {\r\n                        owner[this.expando] = value;\r\n                    }\r\n                    else {\r\n                        Object.defineProperty(owner, this.expando, {\r\n                            value: value,\r\n                            configurable: true\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            return value;\r\n        },\r\n        set: function (owner, data, value) {\r\n            var prop, cache = this.cache(owner);\r\n            // Handle: [ owner, key, value ] args\r\n            // Always use camelCase key (gh-2257)\r\n            if (typeof data === \"string\") {\r\n                cache[jQuery.camelCase(data)] = value;\r\n            }\r\n            else {\r\n                // Copy the properties one-by-one to the cache object\r\n                for (prop in data) {\r\n                    cache[jQuery.camelCase(prop)] = data[prop];\r\n                }\r\n            }\r\n            return cache;\r\n        },\r\n        get: function (owner, key) {\r\n            return key === undefined ?\r\n                this.cache(owner) :\r\n                // Always use camelCase key (gh-2257)\r\n                owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];\r\n        },\r\n        access: function (owner, key, value) {\r\n            // In cases where either:\r\n            //\r\n            //   1. No key was specified\r\n            //   2. A string key was specified, but no value provided\r\n            //\r\n            // Take the \"read\" path and allow the get method to determine\r\n            // which value to return, respectively either:\r\n            //\r\n            //   1. The entire cache object\r\n            //   2. The data stored at the key\r\n            //\r\n            if (key === undefined ||\r\n                ((key && typeof key === \"string\") && value === undefined)) {\r\n                return this.get(owner, key);\r\n            }\r\n            // When the key is not a string, or both a key and value\r\n            // are specified, set or extend (existing objects) with either:\r\n            //\r\n            //   1. An object of properties\r\n            //   2. A key and value\r\n            //\r\n            this.set(owner, key, value);\r\n            // Since the \"set\" path can have two possible entry points\r\n            // return the expected data based on which path was taken[*]\r\n            return value !== undefined ? value : key;\r\n        },\r\n        remove: function (owner, key) {\r\n            var i, cache = owner[this.expando];\r\n            if (cache === undefined) {\r\n                return;\r\n            }\r\n            if (key !== undefined) {\r\n                // Support array or space separated string of keys\r\n                if (jQuery.isArray(key)) {\r\n                    // If key is an array of keys...\r\n                    // We always set camelCase keys, so remove that.\r\n                    key = key.map(jQuery.camelCase);\r\n                }\r\n                else {\r\n                    key = jQuery.camelCase(key);\r\n                    // If a key with the spaces exists, use it.\r\n                    // Otherwise, create an array by matching non-whitespace\r\n                    key = key in cache ?\r\n                        [key] :\r\n                        (key.match(rnothtmlwhite) || []);\r\n                }\r\n                i = key.length;\r\n                while (i--) {\r\n                    delete cache[key[i]];\r\n                }\r\n            }\r\n            // Remove the expando if there's no more data\r\n            if (key === undefined || jQuery.isEmptyObject(cache)) {\r\n                // Support: Chrome <=35 - 45\r\n                // Webkit & Blink performance suffers when deleting properties\r\n                // from DOM nodes, so set to undefined instead\r\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\r\n                if (owner.nodeType) {\r\n                    owner[this.expando] = undefined;\r\n                }\r\n                else {\r\n                    delete owner[this.expando];\r\n                }\r\n            }\r\n        },\r\n        hasData: function (owner) {\r\n            var cache = owner[this.expando];\r\n            return cache !== undefined && !jQuery.isEmptyObject(cache);\r\n        }\r\n    };\r\n    var dataPriv = new Data();\r\n    var dataUser = new Data();\r\n    //\tImplementation Summary\r\n    //\r\n    //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\r\n    //\t2. Improve the module's maintainability by reducing the storage\r\n    //\t\tpaths to a single mechanism.\r\n    //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\r\n    //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\r\n    //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\r\n    //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\r\n    var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/, rmultiDash = /[A-Z]/g;\r\n    function getData(data) {\r\n        if (data === \"true\") {\r\n            return true;\r\n        }\r\n        if (data === \"false\") {\r\n            return false;\r\n        }\r\n        if (data === \"null\") {\r\n            return null;\r\n        }\r\n        // Only convert to a number if it doesn't change the string\r\n        if (data === +data + \"\") {\r\n            return +data;\r\n        }\r\n        if (rbrace.test(data)) {\r\n            return JSON.parse(data);\r\n        }\r\n        return data;\r\n    }\r\n    function dataAttr(elem, key, data) {\r\n        var name;\r\n        // If nothing was found internally, try to fetch any\r\n        // data from the HTML5 data-* attribute\r\n        if (data === undefined && elem.nodeType === 1) {\r\n            name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\r\n            data = elem.getAttribute(name);\r\n            if (typeof data === \"string\") {\r\n                try {\r\n                    data = getData(data);\r\n                }\r\n                catch (e) { }\r\n                // Make sure we set the data so it isn't changed later\r\n                dataUser.set(elem, key, data);\r\n            }\r\n            else {\r\n                data = undefined;\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n    jQuery.extend({\r\n        hasData: function (elem) {\r\n            return dataUser.hasData(elem) || dataPriv.hasData(elem);\r\n        },\r\n        data: function (elem, name, data) {\r\n            return dataUser.access(elem, name, data);\r\n        },\r\n        removeData: function (elem, name) {\r\n            dataUser.remove(elem, name);\r\n        },\r\n        // TODO: Now that all calls to _data and _removeData have been replaced\r\n        // with direct calls to dataPriv methods, these can be deprecated.\r\n        _data: function (elem, name, data) {\r\n            return dataPriv.access(elem, name, data);\r\n        },\r\n        _removeData: function (elem, name) {\r\n            dataPriv.remove(elem, name);\r\n        }\r\n    });\r\n    jQuery.fn.extend({\r\n        data: function (key, value) {\r\n            var i, name, data, elem = this[0], attrs = elem && elem.attributes;\r\n            // Gets all values\r\n            if (key === undefined) {\r\n                if (this.length) {\r\n                    data = dataUser.get(elem);\r\n                    if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\r\n                        i = attrs.length;\r\n                        while (i--) {\r\n                            // Support: IE 11 only\r\n                            // The attrs elements can be null (#14894)\r\n                            if (attrs[i]) {\r\n                                name = attrs[i].name;\r\n                                if (name.indexOf(\"data-\") === 0) {\r\n                                    name = jQuery.camelCase(name.slice(5));\r\n                                    dataAttr(elem, name, data[name]);\r\n                                }\r\n                            }\r\n                        }\r\n                        dataPriv.set(elem, \"hasDataAttrs\", true);\r\n                    }\r\n                }\r\n                return data;\r\n            }\r\n            // Sets multiple values\r\n            if (typeof key === \"object\") {\r\n                return this.each(function () {\r\n                    dataUser.set(this, key);\r\n                });\r\n            }\r\n            return access(this, function (value) {\r\n                var data;\r\n                // The calling jQuery object (element matches) is not empty\r\n                // (and therefore has an element appears at this[ 0 ]) and the\r\n                // `value` parameter was not undefined. An empty jQuery object\r\n                // will result in `undefined` for elem = this[ 0 ] which will\r\n                // throw an exception if an attempt to read a data cache is made.\r\n                if (elem && value === undefined) {\r\n                    // Attempt to get data from the cache\r\n                    // The key will always be camelCased in Data\r\n                    data = dataUser.get(elem, key);\r\n                    if (data !== undefined) {\r\n                        return data;\r\n                    }\r\n                    // Attempt to \"discover\" the data in\r\n                    // HTML5 custom data-* attrs\r\n                    data = dataAttr(elem, key);\r\n                    if (data !== undefined) {\r\n                        return data;\r\n                    }\r\n                    // We tried really hard, but the data doesn't exist.\r\n                    return;\r\n                }\r\n                // Set the data...\r\n                this.each(function () {\r\n                    // We always store the camelCased key\r\n                    dataUser.set(this, key, value);\r\n                });\r\n            }, null, value, arguments.length > 1, null, true);\r\n        },\r\n        removeData: function (key) {\r\n            return this.each(function () {\r\n                dataUser.remove(this, key);\r\n            });\r\n        }\r\n    });\r\n    jQuery.extend({\r\n        queue: function (elem, type, data) {\r\n            var queue;\r\n            if (elem) {\r\n                type = (type || \"fx\") + \"queue\";\r\n                queue = dataPriv.get(elem, type);\r\n                // Speed up dequeue by getting out quickly if this is just a lookup\r\n                if (data) {\r\n                    if (!queue || jQuery.isArray(data)) {\r\n                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));\r\n                    }\r\n                    else {\r\n                        queue.push(data);\r\n                    }\r\n                }\r\n                return queue || [];\r\n            }\r\n        },\r\n        dequeue: function (elem, type) {\r\n            type = type || \"fx\";\r\n            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {\r\n                jQuery.dequeue(elem, type);\r\n            };\r\n            // If the fx queue is dequeued, always remove the progress sentinel\r\n            if (fn === \"inprogress\") {\r\n                fn = queue.shift();\r\n                startLength--;\r\n            }\r\n            if (fn) {\r\n                // Add a progress sentinel to prevent the fx queue from being\r\n                // automatically dequeued\r\n                if (type === \"fx\") {\r\n                    queue.unshift(\"inprogress\");\r\n                }\r\n                // Clear up the last queue stop function\r\n                delete hooks.stop;\r\n                fn.call(elem, next, hooks);\r\n            }\r\n            if (!startLength && hooks) {\r\n                hooks.empty.fire();\r\n            }\r\n        },\r\n        // Not public - generate a queueHooks object, or return the current one\r\n        _queueHooks: function (elem, type) {\r\n            var key = type + \"queueHooks\";\r\n            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\r\n                empty: jQuery.Callbacks(\"once memory\").add(function () {\r\n                    dataPriv.remove(elem, [type + \"queue\", key]);\r\n                })\r\n            });\r\n        }\r\n    });\r\n    jQuery.fn.extend({\r\n        queue: function (type, data) {\r\n            var setter = 2;\r\n            if (typeof type !== \"string\") {\r\n                data = type;\r\n                type = \"fx\";\r\n                setter--;\r\n            }\r\n            if (arguments.length < setter) {\r\n                return jQuery.queue(this[0], type);\r\n            }\r\n            return data === undefined ?\r\n                this :\r\n                this.each(function () {\r\n                    var queue = jQuery.queue(this, type, data);\r\n                    // Ensure a hooks for this queue\r\n                    jQuery._queueHooks(this, type);\r\n                    if (type === \"fx\" && queue[0] !== \"inprogress\") {\r\n                        jQuery.dequeue(this, type);\r\n                    }\r\n                });\r\n        },\r\n        dequeue: function (type) {\r\n            return this.each(function () {\r\n                jQuery.dequeue(this, type);\r\n            });\r\n        },\r\n        clearQueue: function (type) {\r\n            return this.queue(type || \"fx\", []);\r\n        },\r\n        // Get a promise resolved when queues of a certain type\r\n        // are emptied (fx is the type by default)\r\n        promise: function (type, obj) {\r\n            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {\r\n                if (!(--count)) {\r\n                    defer.resolveWith(elements, [elements]);\r\n                }\r\n            };\r\n            if (typeof type !== \"string\") {\r\n                obj = type;\r\n                type = undefined;\r\n            }\r\n            type = type || \"fx\";\r\n            while (i--) {\r\n                tmp = dataPriv.get(elements[i], type + \"queueHooks\");\r\n                if (tmp && tmp.empty) {\r\n                    count++;\r\n                    tmp.empty.add(resolve);\r\n                }\r\n            }\r\n            resolve();\r\n            return defer.promise(obj);\r\n        }\r\n    });\r\n    var pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\r\n    var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\r\n    var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\r\n    var isHiddenWithinTree = function (elem, el) {\r\n        // isHiddenWithinTree might be called from jQuery#filter function;\r\n        // in that case, element will be second argument\r\n        elem = el || elem;\r\n        // Inline style trumps all\r\n        return elem.style.display === \"none\" ||\r\n            elem.style.display === \"\" &&\r\n                // Otherwise, check computed style\r\n                // Support: Firefox <=43 - 45\r\n                // Disconnected elements can have computed display: none, so first confirm that elem is\r\n                // in the document.\r\n                jQuery.contains(elem.ownerDocument, elem) &&\r\n                jQuery.css(elem, \"display\") === \"none\";\r\n    };\r\n    var swap = function (elem, options, callback, args) {\r\n        var ret, name, old = {};\r\n        // Remember the old values, and insert the new ones\r\n        for (name in options) {\r\n            old[name] = elem.style[name];\r\n            elem.style[name] = options[name];\r\n        }\r\n        ret = callback.apply(elem, args || []);\r\n        // Revert the old values\r\n        for (name in options) {\r\n            elem.style[name] = old[name];\r\n        }\r\n        return ret;\r\n    };\r\n    function adjustCSS(elem, prop, valueParts, tween) {\r\n        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ?\r\n            function () {\r\n                return tween.cur();\r\n            } :\r\n            function () {\r\n                return jQuery.css(elem, prop, \"\");\r\n            }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"), \r\n        // Starting value computation is required for potential unit mismatches\r\n        initialInUnit = (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) &&\r\n            rcssNum.exec(jQuery.css(elem, prop));\r\n        if (initialInUnit && initialInUnit[3] !== unit) {\r\n            // Trust units reported by jQuery.css\r\n            unit = unit || initialInUnit[3];\r\n            // Make sure we update the tween properties later on\r\n            valueParts = valueParts || [];\r\n            // Iteratively approximate from a nonzero starting point\r\n            initialInUnit = +initial || 1;\r\n            do {\r\n                // If previous iteration zeroed out, double until we get *something*.\r\n                // Use string for doubling so we don't accidentally see scale as unchanged below\r\n                scale = scale || \".5\";\r\n                // Adjust and apply\r\n                initialInUnit = initialInUnit / scale;\r\n                jQuery.style(elem, prop, initialInUnit + unit);\r\n            } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);\r\n        }\r\n        if (valueParts) {\r\n            initialInUnit = +initialInUnit || +initial || 0;\r\n            // Apply relative offset (+=/-=) if specified\r\n            adjusted = valueParts[1] ?\r\n                initialInUnit + (valueParts[1] + 1) * valueParts[2] :\r\n                +valueParts[2];\r\n            if (tween) {\r\n                tween.unit = unit;\r\n                tween.start = initialInUnit;\r\n                tween.end = adjusted;\r\n            }\r\n        }\r\n        return adjusted;\r\n    }\r\n    var defaultDisplayMap = {};\r\n    function getDefaultDisplay(elem) {\r\n        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];\r\n        if (display) {\r\n            return display;\r\n        }\r\n        temp = doc.body.appendChild(doc.createElement(nodeName));\r\n        display = jQuery.css(temp, \"display\");\r\n        temp.parentNode.removeChild(temp);\r\n        if (display === \"none\") {\r\n            display = \"block\";\r\n        }\r\n        defaultDisplayMap[nodeName] = display;\r\n        return display;\r\n    }\r\n    function showHide(elements, show) {\r\n        var display, elem, values = [], index = 0, length = elements.length;\r\n        // Determine new display value for elements that need to change\r\n        for (; index < length; index++) {\r\n            elem = elements[index];\r\n            if (!elem.style) {\r\n                continue;\r\n            }\r\n            display = elem.style.display;\r\n            if (show) {\r\n                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\r\n                // check is required in this first loop unless we have a nonempty display value (either\r\n                // inline or about-to-be-restored)\r\n                if (display === \"none\") {\r\n                    values[index] = dataPriv.get(elem, \"display\") || null;\r\n                    if (!values[index]) {\r\n                        elem.style.display = \"\";\r\n                    }\r\n                }\r\n                if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\r\n                    values[index] = getDefaultDisplay(elem);\r\n                }\r\n            }\r\n            else {\r\n                if (display !== \"none\") {\r\n                    values[index] = \"none\";\r\n                    // Remember what we're overwriting\r\n                    dataPriv.set(elem, \"display\", display);\r\n                }\r\n            }\r\n        }\r\n        // Set the display of the elements in a second loop to avoid constant reflow\r\n        for (index = 0; index < length; index++) {\r\n            if (values[index] != null) {\r\n                elements[index].style.display = values[index];\r\n            }\r\n        }\r\n        return elements;\r\n    }\r\n    jQuery.fn.extend({\r\n        show: function () {\r\n            return showHide(this, true);\r\n        },\r\n        hide: function () {\r\n            return showHide(this);\r\n        },\r\n        toggle: function (state) {\r\n            if (typeof state === \"boolean\") {\r\n                return state ? this.show() : this.hide();\r\n            }\r\n            return this.each(function () {\r\n                if (isHiddenWithinTree(this)) {\r\n                    jQuery(this).show();\r\n                }\r\n                else {\r\n                    jQuery(this).hide();\r\n                }\r\n            });\r\n        }\r\n    });\r\n    var rcheckableType = (/^(?:checkbox|radio)$/i);\r\n    var rtagName = (/<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i);\r\n    var rscriptType = (/^$|\\/(?:java|ecma)script/i);\r\n    // We have to close these tags to support XHTML (#13200)\r\n    var wrapMap = {\r\n        // Support: IE <=9 only\r\n        option: [1, \"<select multiple='multiple'>\", \"</select>\"],\r\n        // XHTML parsers do not magically insert elements in the\r\n        // same way that tag soup parsers do. So we cannot shorten\r\n        // this by omitting <tbody> or other required elements.\r\n        thead: [1, \"<table>\", \"</table>\"],\r\n        col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\r\n        tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\r\n        td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\r\n        _default: [0, \"\", \"\"]\r\n    };\r\n    // Support: IE <=9 only\r\n    wrapMap.optgroup = wrapMap.option;\r\n    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\r\n    wrapMap.th = wrapMap.td;\r\n    function getAll(context, tag) {\r\n        // Support: IE <=9 - 11 only\r\n        // Use typeof to avoid zero-argument method invocation on host objects (#15151)\r\n        var ret;\r\n        if (typeof context.getElementsByTagName !== \"undefined\") {\r\n            ret = context.getElementsByTagName(tag || \"*\");\r\n        }\r\n        else if (typeof context.querySelectorAll !== \"undefined\") {\r\n            ret = context.querySelectorAll(tag || \"*\");\r\n        }\r\n        else {\r\n            ret = [];\r\n        }\r\n        if (tag === undefined || tag && jQuery.nodeName(context, tag)) {\r\n            return jQuery.merge([context], ret);\r\n        }\r\n        return ret;\r\n    }\r\n    // Mark scripts as having already been evaluated\r\n    function setGlobalEval(elems, refElements) {\r\n        var i = 0, l = elems.length;\r\n        for (; i < l; i++) {\r\n            dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\r\n        }\r\n    }\r\n    var rhtml = /<|&#?\\w+;/;\r\n    function buildFragment(elems, context, scripts, selection, ignored) {\r\n        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;\r\n        for (; i < l; i++) {\r\n            elem = elems[i];\r\n            if (elem || elem === 0) {\r\n                // Add nodes directly\r\n                if (jQuery.type(elem) === \"object\") {\r\n                    // Support: Android <=4.0 only, PhantomJS 1 only\r\n                    // push.apply(_, arraylike) throws on ancient WebKit\r\n                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);\r\n                }\r\n                else if (!rhtml.test(elem)) {\r\n                    nodes.push(context.createTextNode(elem));\r\n                }\r\n                else {\r\n                    tmp = tmp || fragment.appendChild(context.createElement(\"div\"));\r\n                    // Deserialize a standard representation\r\n                    tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\r\n                    wrap = wrapMap[tag] || wrapMap._default;\r\n                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];\r\n                    // Descend through wrappers to the right content\r\n                    j = wrap[0];\r\n                    while (j--) {\r\n                        tmp = tmp.lastChild;\r\n                    }\r\n                    // Support: Android <=4.0 only, PhantomJS 1 only\r\n                    // push.apply(_, arraylike) throws on ancient WebKit\r\n                    jQuery.merge(nodes, tmp.childNodes);\r\n                    // Remember the top-level container\r\n                    tmp = fragment.firstChild;\r\n                    // Ensure the created nodes are orphaned (#12392)\r\n                    tmp.textContent = \"\";\r\n                }\r\n            }\r\n        }\r\n        // Remove wrapper from fragment\r\n        fragment.textContent = \"\";\r\n        i = 0;\r\n        while ((elem = nodes[i++])) {\r\n            // Skip elements already in the context collection (trac-4087)\r\n            if (selection && jQuery.inArray(elem, selection) > -1) {\r\n                if (ignored) {\r\n                    ignored.push(elem);\r\n                }\r\n                continue;\r\n            }\r\n            contains = jQuery.contains(elem.ownerDocument, elem);\r\n            // Append to fragment\r\n            tmp = getAll(fragment.appendChild(elem), \"script\");\r\n            // Preserve script evaluation history\r\n            if (contains) {\r\n                setGlobalEval(tmp);\r\n            }\r\n            // Capture executables\r\n            if (scripts) {\r\n                j = 0;\r\n                while ((elem = tmp[j++])) {\r\n                    if (rscriptType.test(elem.type || \"\")) {\r\n                        scripts.push(elem);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return fragment;\r\n    }\r\n    (function () {\r\n        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement(\"div\")), input = document.createElement(\"input\");\r\n        // Support: Android 4.0 - 4.3 only\r\n        // Check state lost if the name is set (#11217)\r\n        // Support: Windows Web Apps (WWA)\r\n        // `name` and `type` must use .setAttribute for WWA (#14901)\r\n        input.setAttribute(\"type\", \"radio\");\r\n        input.setAttribute(\"checked\", \"checked\");\r\n        input.setAttribute(\"name\", \"t\");\r\n        div.appendChild(input);\r\n        // Support: Android <=4.1 only\r\n        // Older WebKit doesn't clone checked state correctly in fragments\r\n        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\r\n        // Support: IE <=11 only\r\n        // Make sure textarea (and checkbox) defaultValue is properly cloned\r\n        div.innerHTML = \"<textarea>x</textarea>\";\r\n        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\r\n    })();\r\n    var documentElement = document.documentElement;\r\n    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\r\n    function returnTrue() {\r\n        return true;\r\n    }\r\n    function returnFalse() {\r\n        return false;\r\n    }\r\n    // Support: IE <=9 only\r\n    // See #13393 for more info\r\n    function safeActiveElement() {\r\n        try {\r\n            return document.activeElement;\r\n        }\r\n        catch (err) { }\r\n    }\r\n    function on(elem, types, selector, data, fn, one) {\r\n        var origFn, type;\r\n        // Types can be a map of types/handlers\r\n        if (typeof types === \"object\") {\r\n            // ( types-Object, selector, data )\r\n            if (typeof selector !== \"string\") {\r\n                // ( types-Object, data )\r\n                data = data || selector;\r\n                selector = undefined;\r\n            }\r\n            for (type in types) {\r\n                on(elem, type, selector, data, types[type], one);\r\n            }\r\n            return elem;\r\n        }\r\n        if (data == null && fn == null) {\r\n            // ( types, fn )\r\n            fn = selector;\r\n            data = selector = undefined;\r\n        }\r\n        else if (fn == null) {\r\n            if (typeof selector === \"string\") {\r\n                // ( types, selector, fn )\r\n                fn = data;\r\n                data = undefined;\r\n            }\r\n            else {\r\n                // ( types, data, fn )\r\n                fn = data;\r\n                data = selector;\r\n                selector = undefined;\r\n            }\r\n        }\r\n        if (fn === false) {\r\n            fn = returnFalse;\r\n        }\r\n        else if (!fn) {\r\n            return elem;\r\n        }\r\n        if (one === 1) {\r\n            origFn = fn;\r\n            fn = function (event) {\r\n                // Can use an empty set, since event contains the info\r\n                jQuery().off(event);\r\n                return origFn.apply(this, arguments);\r\n            };\r\n            // Use same guid so caller can remove using origFn\r\n            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\r\n        }\r\n        return elem.each(function () {\r\n            jQuery.event.add(this, types, fn, data, selector);\r\n        });\r\n    }\r\n    /*\r\n     * Helper functions for managing events -- not part of the public interface.\r\n     * Props to Dean Edwards' addEvent library for many of the ideas.\r\n     */\r\n    jQuery.event = {\r\n        global: {},\r\n        add: function (elem, types, handler, data, selector) {\r\n            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);\r\n            // Don't attach events to noData or text/comment nodes (but allow plain objects)\r\n            if (!elemData) {\r\n                return;\r\n            }\r\n            // Caller can pass in an object of custom data in lieu of the handler\r\n            if (handler.handler) {\r\n                handleObjIn = handler;\r\n                handler = handleObjIn.handler;\r\n                selector = handleObjIn.selector;\r\n            }\r\n            // Ensure that invalid selectors throw exceptions at attach time\r\n            // Evaluate against documentElement in case elem is a non-element node (e.g., document)\r\n            if (selector) {\r\n                jQuery.find.matchesSelector(documentElement, selector);\r\n            }\r\n            // Make sure that the handler has a unique ID, used to find/remove it later\r\n            if (!handler.guid) {\r\n                handler.guid = jQuery.guid++;\r\n            }\r\n            // Init the element's event structure and main handler, if this is the first\r\n            if (!(events = elemData.events)) {\r\n                events = elemData.events = {};\r\n            }\r\n            if (!(eventHandle = elemData.handle)) {\r\n                eventHandle = elemData.handle = function (e) {\r\n                    // Discard the second event of a jQuery.event.trigger() and\r\n                    // when an event is called after a page has unloaded\r\n                    return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\r\n                        jQuery.event.dispatch.apply(elem, arguments) : undefined;\r\n                };\r\n            }\r\n            // Handle multiple events separated by a space\r\n            types = (types || \"\").match(rnothtmlwhite) || [\"\"];\r\n            t = types.length;\r\n            while (t--) {\r\n                tmp = rtypenamespace.exec(types[t]) || [];\r\n                type = origType = tmp[1];\r\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\r\n                // There *must* be a type, no attaching namespace-only handlers\r\n                if (!type) {\r\n                    continue;\r\n                }\r\n                // If event changes its type, use the special event handlers for the changed type\r\n                special = jQuery.event.special[type] || {};\r\n                // If selector defined, determine special event api type, otherwise given type\r\n                type = (selector ? special.delegateType : special.bindType) || type;\r\n                // Update special based on newly reset type\r\n                special = jQuery.event.special[type] || {};\r\n                // handleObj is passed to all event handlers\r\n                handleObj = jQuery.extend({\r\n                    type: type,\r\n                    origType: origType,\r\n                    data: data,\r\n                    handler: handler,\r\n                    guid: handler.guid,\r\n                    selector: selector,\r\n                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),\r\n                    namespace: namespaces.join(\".\")\r\n                }, handleObjIn);\r\n                // Init the event handler queue if we're the first\r\n                if (!(handlers = events[type])) {\r\n                    handlers = events[type] = [];\r\n                    handlers.delegateCount = 0;\r\n                    // Only use addEventListener if the special events handler returns false\r\n                    if (!special.setup ||\r\n                        special.setup.call(elem, data, namespaces, eventHandle) === false) {\r\n                        if (elem.addEventListener) {\r\n                            elem.addEventListener(type, eventHandle);\r\n                        }\r\n                    }\r\n                }\r\n                if (special.add) {\r\n                    special.add.call(elem, handleObj);\r\n                    if (!handleObj.handler.guid) {\r\n                        handleObj.handler.guid = handler.guid;\r\n                    }\r\n                }\r\n                // Add to the element's handler list, delegates in front\r\n                if (selector) {\r\n                    handlers.splice(handlers.delegateCount++, 0, handleObj);\r\n                }\r\n                else {\r\n                    handlers.push(handleObj);\r\n                }\r\n                // Keep track of which events have ever been used, for event optimization\r\n                jQuery.event.global[type] = true;\r\n            }\r\n        },\r\n        // Detach an event or set of events from an element\r\n        remove: function (elem, types, handler, selector, mappedTypes) {\r\n            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\r\n            if (!elemData || !(events = elemData.events)) {\r\n                return;\r\n            }\r\n            // Once for each type.namespace in types; type may be omitted\r\n            types = (types || \"\").match(rnothtmlwhite) || [\"\"];\r\n            t = types.length;\r\n            while (t--) {\r\n                tmp = rtypenamespace.exec(types[t]) || [];\r\n                type = origType = tmp[1];\r\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\r\n                // Unbind all events (on this namespace, if provided) for the element\r\n                if (!type) {\r\n                    for (type in events) {\r\n                        jQuery.event.remove(elem, type + types[t], handler, selector, true);\r\n                    }\r\n                    continue;\r\n                }\r\n                special = jQuery.event.special[type] || {};\r\n                type = (selector ? special.delegateType : special.bindType) || type;\r\n                handlers = events[type] || [];\r\n                tmp = tmp[2] &&\r\n                    new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\");\r\n                // Remove matching events\r\n                origCount = j = handlers.length;\r\n                while (j--) {\r\n                    handleObj = handlers[j];\r\n                    if ((mappedTypes || origType === handleObj.origType) &&\r\n                        (!handler || handler.guid === handleObj.guid) &&\r\n                        (!tmp || tmp.test(handleObj.namespace)) &&\r\n                        (!selector || selector === handleObj.selector ||\r\n                            selector === \"**\" && handleObj.selector)) {\r\n                        handlers.splice(j, 1);\r\n                        if (handleObj.selector) {\r\n                            handlers.delegateCount--;\r\n                        }\r\n                        if (special.remove) {\r\n                            special.remove.call(elem, handleObj);\r\n                        }\r\n                    }\r\n                }\r\n                // Remove generic event handler if we removed something and no more handlers exist\r\n                // (avoids potential for endless recursion during removal of special event handlers)\r\n                if (origCount && !handlers.length) {\r\n                    if (!special.teardown ||\r\n                        special.teardown.call(elem, namespaces, elemData.handle) === false) {\r\n                        jQuery.removeEvent(elem, type, elemData.handle);\r\n                    }\r\n                    delete events[type];\r\n                }\r\n            }\r\n            // Remove data and the expando if it's no longer used\r\n            if (jQuery.isEmptyObject(events)) {\r\n                dataPriv.remove(elem, \"handle events\");\r\n            }\r\n        },\r\n        dispatch: function (nativeEvent) {\r\n            // Make a writable jQuery.Event from the native event object\r\n            var event = jQuery.event.fix(nativeEvent);\r\n            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), handlers = (dataPriv.get(this, \"events\") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};\r\n            // Use the fix-ed jQuery.Event rather than the (read-only) native event\r\n            args[0] = event;\r\n            for (i = 1; i < arguments.length; i++) {\r\n                args[i] = arguments[i];\r\n            }\r\n            event.delegateTarget = this;\r\n            // Call the preDispatch hook for the mapped type, and let it bail if desired\r\n            if (special.preDispatch && special.preDispatch.call(this, event) === false) {\r\n                return;\r\n            }\r\n            // Determine handlers\r\n            handlerQueue = jQuery.event.handlers.call(this, event, handlers);\r\n            // Run delegates first; they may want to stop propagation beneath us\r\n            i = 0;\r\n            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\r\n                event.currentTarget = matched.elem;\r\n                j = 0;\r\n                while ((handleObj = matched.handlers[j++]) &&\r\n                    !event.isImmediatePropagationStopped()) {\r\n                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)\r\n                    // a subset or equal to those in the bound event (both can have no namespace).\r\n                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {\r\n                        event.handleObj = handleObj;\r\n                        event.data = handleObj.data;\r\n                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||\r\n                            handleObj.handler).apply(matched.elem, args);\r\n                        if (ret !== undefined) {\r\n                            if ((event.result = ret) === false) {\r\n                                event.preventDefault();\r\n                                event.stopPropagation();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Call the postDispatch hook for the mapped type\r\n            if (special.postDispatch) {\r\n                special.postDispatch.call(this, event);\r\n            }\r\n            return event.result;\r\n        },\r\n        handlers: function (event, handlers) {\r\n            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;\r\n            // Find delegate handlers\r\n            if (delegateCount &&\r\n                // Support: IE <=9\r\n                // Black-hole SVG <use> instance trees (trac-13180)\r\n                cur.nodeType &&\r\n                // Support: Firefox <=42\r\n                // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\r\n                // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\r\n                // Support: IE 11 only\r\n                // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\r\n                !(event.type === \"click\" && event.button >= 1)) {\r\n                for (; cur !== this; cur = cur.parentNode || this) {\r\n                    // Don't check non-elements (#13208)\r\n                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\r\n                    if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\r\n                        matchedHandlers = [];\r\n                        matchedSelectors = {};\r\n                        for (i = 0; i < delegateCount; i++) {\r\n                            handleObj = handlers[i];\r\n                            // Don't conflict with Object.prototype properties (#13203)\r\n                            sel = handleObj.selector + \" \";\r\n                            if (matchedSelectors[sel] === undefined) {\r\n                                matchedSelectors[sel] = handleObj.needsContext ?\r\n                                    jQuery(sel, this).index(cur) > -1 :\r\n                                    jQuery.find(sel, this, null, [cur]).length;\r\n                            }\r\n                            if (matchedSelectors[sel]) {\r\n                                matchedHandlers.push(handleObj);\r\n                            }\r\n                        }\r\n                        if (matchedHandlers.length) {\r\n                            handlerQueue.push({ elem: cur, handlers: matchedHandlers });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Add the remaining (directly-bound) handlers\r\n            cur = this;\r\n            if (delegateCount < handlers.length) {\r\n                handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });\r\n            }\r\n            return handlerQueue;\r\n        },\r\n        addProp: function (name, hook) {\r\n            Object.defineProperty(jQuery.Event.prototype, name, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: jQuery.isFunction(hook) ?\r\n                    function () {\r\n                        if (this.originalEvent) {\r\n                            return hook(this.originalEvent);\r\n                        }\r\n                    } :\r\n                    function () {\r\n                        if (this.originalEvent) {\r\n                            return this.originalEvent[name];\r\n                        }\r\n                    },\r\n                set: function (value) {\r\n                    Object.defineProperty(this, name, {\r\n                        enumerable: true,\r\n                        configurable: true,\r\n                        writable: true,\r\n                        value: value\r\n                    });\r\n                }\r\n            });\r\n        },\r\n        fix: function (originalEvent) {\r\n            return originalEvent[jQuery.expando] ?\r\n                originalEvent :\r\n                new jQuery.Event(originalEvent);\r\n        },\r\n        special: {\r\n            load: {\r\n                // Prevent triggered image.load events from bubbling to window.load\r\n                noBubble: true\r\n            },\r\n            focus: {\r\n                // Fire native event if possible so blur/focus sequence is correct\r\n                trigger: function () {\r\n                    if (this !== safeActiveElement() && this.focus) {\r\n                        this.focus();\r\n                        return false;\r\n                    }\r\n                },\r\n                delegateType: \"focusin\"\r\n            },\r\n            blur: {\r\n                trigger: function () {\r\n                    if (this === safeActiveElement() && this.blur) {\r\n                        this.blur();\r\n                        return false;\r\n                    }\r\n                },\r\n                delegateType: \"focusout\"\r\n            },\r\n            click: {\r\n                // For checkbox, fire native event so checked state will be right\r\n                trigger: function () {\r\n                    if (this.type === \"checkbox\" && this.click && jQuery.nodeName(this, \"input\")) {\r\n                        this.click();\r\n                        return false;\r\n                    }\r\n                },\r\n                // For cross-browser consistency, don't fire native .click() on links\r\n                _default: function (event) {\r\n                    return jQuery.nodeName(event.target, \"a\");\r\n                }\r\n            },\r\n            beforeunload: {\r\n                postDispatch: function (event) {\r\n                    // Support: Firefox 20+\r\n                    // Firefox doesn't alert if the returnValue field is not set.\r\n                    if (event.result !== undefined && event.originalEvent) {\r\n                        event.originalEvent.returnValue = event.result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    jQuery.removeEvent = function (elem, type, handle) {\r\n        // This \"if\" is needed for plain objects\r\n        if (elem.removeEventListener) {\r\n            elem.removeEventListener(type, handle);\r\n        }\r\n    };\r\n    jQuery.Event = function (src, props) {\r\n        // Allow instantiation without the 'new' keyword\r\n        if (!(this instanceof jQuery.Event)) {\r\n            return new jQuery.Event(src, props);\r\n        }\r\n        // Event object\r\n        if (src && src.type) {\r\n            this.originalEvent = src;\r\n            this.type = src.type;\r\n            // Events bubbling up the document may have been marked as prevented\r\n            // by a handler lower down the tree; reflect the correct value.\r\n            this.isDefaultPrevented = src.defaultPrevented ||\r\n                src.defaultPrevented === undefined &&\r\n                    // Support: Android <=2.3 only\r\n                    src.returnValue === false ?\r\n                returnTrue :\r\n                returnFalse;\r\n            // Create target properties\r\n            // Support: Safari <=6 - 7 only\r\n            // Target should not be a text node (#504, #13143)\r\n            this.target = (src.target && src.target.nodeType === 3) ?\r\n                src.target.parentNode :\r\n                src.target;\r\n            this.currentTarget = src.currentTarget;\r\n            this.relatedTarget = src.relatedTarget;\r\n        }\r\n        else {\r\n            this.type = src;\r\n        }\r\n        // Put explicitly provided properties onto the event object\r\n        if (props) {\r\n            jQuery.extend(this, props);\r\n        }\r\n        // Create a timestamp if incoming event doesn't have one\r\n        this.timeStamp = src && src.timeStamp || jQuery.now();\r\n        // Mark it as fixed\r\n        this[jQuery.expando] = true;\r\n    };\r\n    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\r\n    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\r\n    jQuery.Event.prototype = {\r\n        constructor: jQuery.Event,\r\n        isDefaultPrevented: returnFalse,\r\n        isPropagationStopped: returnFalse,\r\n        isImmediatePropagationStopped: returnFalse,\r\n        isSimulated: false,\r\n        preventDefault: function () {\r\n            var e = this.originalEvent;\r\n            this.isDefaultPrevented = returnTrue;\r\n            if (e && !this.isSimulated) {\r\n                e.preventDefault();\r\n            }\r\n        },\r\n        stopPropagation: function () {\r\n            var e = this.originalEvent;\r\n            this.isPropagationStopped = returnTrue;\r\n            if (e && !this.isSimulated) {\r\n                e.stopPropagation();\r\n            }\r\n        },\r\n        stopImmediatePropagation: function () {\r\n            var e = this.originalEvent;\r\n            this.isImmediatePropagationStopped = returnTrue;\r\n            if (e && !this.isSimulated) {\r\n                e.stopImmediatePropagation();\r\n            }\r\n            this.stopPropagation();\r\n        }\r\n    };\r\n    // Includes all common event props including KeyEvent and MouseEvent specific props\r\n    jQuery.each({\r\n        altKey: true,\r\n        bubbles: true,\r\n        cancelable: true,\r\n        changedTouches: true,\r\n        ctrlKey: true,\r\n        detail: true,\r\n        eventPhase: true,\r\n        metaKey: true,\r\n        pageX: true,\r\n        pageY: true,\r\n        shiftKey: true,\r\n        view: true,\r\n        \"char\": true,\r\n        charCode: true,\r\n        key: true,\r\n        keyCode: true,\r\n        button: true,\r\n        buttons: true,\r\n        clientX: true,\r\n        clientY: true,\r\n        offsetX: true,\r\n        offsetY: true,\r\n        pointerId: true,\r\n        pointerType: true,\r\n        screenX: true,\r\n        screenY: true,\r\n        targetTouches: true,\r\n        toElement: true,\r\n        touches: true,\r\n        which: function (event) {\r\n            var button = event.button;\r\n            // Add which for key events\r\n            if (event.which == null && rkeyEvent.test(event.type)) {\r\n                return event.charCode != null ? event.charCode : event.keyCode;\r\n            }\r\n            // Add which for click: 1 === left; 2 === middle; 3 === right\r\n            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {\r\n                if (button & 1) {\r\n                    return 1;\r\n                }\r\n                if (button & 2) {\r\n                    return 3;\r\n                }\r\n                if (button & 4) {\r\n                    return 2;\r\n                }\r\n                return 0;\r\n            }\r\n            return event.which;\r\n        }\r\n    }, jQuery.event.addProp);\r\n    // Create mouseenter/leave events using mouseover/out and event-time checks\r\n    // so that event delegation works in jQuery.\r\n    // Do the same for pointerenter/pointerleave and pointerover/pointerout\r\n    //\r\n    // Support: Safari 7 only\r\n    // Safari sends mouseenter too often; see:\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\r\n    // for the description of the bug (it existed in older Chrome versions as well).\r\n    jQuery.each({\r\n        mouseenter: \"mouseover\",\r\n        mouseleave: \"mouseout\",\r\n        pointerenter: \"pointerover\",\r\n        pointerleave: \"pointerout\"\r\n    }, function (orig, fix) {\r\n        jQuery.event.special[orig] = {\r\n            delegateType: fix,\r\n            bindType: fix,\r\n            handle: function (event) {\r\n                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;\r\n                // For mouseenter/leave call the handler if related is outside the target.\r\n                // NB: No relatedTarget if the mouse left/entered the browser window\r\n                if (!related || (related !== target && !jQuery.contains(target, related))) {\r\n                    event.type = handleObj.origType;\r\n                    ret = handleObj.handler.apply(this, arguments);\r\n                    event.type = fix;\r\n                }\r\n                return ret;\r\n            }\r\n        };\r\n    });\r\n    jQuery.fn.extend({\r\n        on: function (types, selector, data, fn) {\r\n            return on(this, types, selector, data, fn);\r\n        },\r\n        one: function (types, selector, data, fn) {\r\n            return on(this, types, selector, data, fn, 1);\r\n        },\r\n        off: function (types, selector, fn) {\r\n            var handleObj, type;\r\n            if (types && types.preventDefault && types.handleObj) {\r\n                // ( event )  dispatched jQuery.Event\r\n                handleObj = types.handleObj;\r\n                jQuery(types.delegateTarget).off(handleObj.namespace ?\r\n                    handleObj.origType + \".\" + handleObj.namespace :\r\n                    handleObj.origType, handleObj.selector, handleObj.handler);\r\n                return this;\r\n            }\r\n            if (typeof types === \"object\") {\r\n                // ( types-object [, selector] )\r\n                for (type in types) {\r\n                    this.off(type, selector, types[type]);\r\n                }\r\n                return this;\r\n            }\r\n            if (selector === false || typeof selector === \"function\") {\r\n                // ( types [, fn] )\r\n                fn = selector;\r\n                selector = undefined;\r\n            }\r\n            if (fn === false) {\r\n                fn = returnFalse;\r\n            }\r\n            return this.each(function () {\r\n                jQuery.event.remove(this, types, fn, selector);\r\n            });\r\n        }\r\n    });\r\n    var \r\n    /* eslint-disable max-len */\r\n    // See https://github.com/eslint/eslint/issues/3229\r\n    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi, \r\n    /* eslint-enable */\r\n    // Support: IE <=10 - 11, Edge 12 - 13\r\n    // In IE/Edge using regex groups here causes severe slowdowns.\r\n    // See https://connect.microsoft.com/IE/feedback/details/1736512/\r\n    rnoInnerhtml = /<script|<style|<link/i, \r\n    // checked=\"checked\" or checked\r\n    rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i, rscriptTypeMasked = /^true\\/(.*)/, rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\r\n    function manipulationTarget(elem, content) {\r\n        if (jQuery.nodeName(elem, \"table\") &&\r\n            jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\r\n            return elem.getElementsByTagName(\"tbody\")[0] || elem;\r\n        }\r\n        return elem;\r\n    }\r\n    // Replace/restore the type attribute of script elements for safe DOM manipulation\r\n    function disableScript(elem) {\r\n        elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\r\n        return elem;\r\n    }\r\n    function restoreScript(elem) {\r\n        var match = rscriptTypeMasked.exec(elem.type);\r\n        if (match) {\r\n            elem.type = match[1];\r\n        }\r\n        else {\r\n            elem.removeAttribute(\"type\");\r\n        }\r\n        return elem;\r\n    }\r\n    function cloneCopyEvent(src, dest) {\r\n        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\r\n        if (dest.nodeType !== 1) {\r\n            return;\r\n        }\r\n        // 1. Copy private data: events, handlers, etc.\r\n        if (dataPriv.hasData(src)) {\r\n            pdataOld = dataPriv.access(src);\r\n            pdataCur = dataPriv.set(dest, pdataOld);\r\n            events = pdataOld.events;\r\n            if (events) {\r\n                delete pdataCur.handle;\r\n                pdataCur.events = {};\r\n                for (type in events) {\r\n                    for (i = 0, l = events[type].length; i < l; i++) {\r\n                        jQuery.event.add(dest, type, events[type][i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // 2. Copy user data\r\n        if (dataUser.hasData(src)) {\r\n            udataOld = dataUser.access(src);\r\n            udataCur = jQuery.extend({}, udataOld);\r\n            dataUser.set(dest, udataCur);\r\n        }\r\n    }\r\n    // Fix IE bugs, see support tests\r\n    function fixInput(src, dest) {\r\n        var nodeName = dest.nodeName.toLowerCase();\r\n        // Fails to persist the checked state of a cloned checkbox or radio button.\r\n        if (nodeName === \"input\" && rcheckableType.test(src.type)) {\r\n            dest.checked = src.checked;\r\n        }\r\n        else if (nodeName === \"input\" || nodeName === \"textarea\") {\r\n            dest.defaultValue = src.defaultValue;\r\n        }\r\n    }\r\n    function domManip(collection, args, callback, ignored) {\r\n        // Flatten any nested arrays\r\n        args = concat.apply([], args);\r\n        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);\r\n        // We can't cloneNode fragments that contain checked, in WebKit\r\n        if (isFunction ||\r\n            (l > 1 && typeof value === \"string\" &&\r\n                !support.checkClone && rchecked.test(value))) {\r\n            return collection.each(function (index) {\r\n                var self = collection.eq(index);\r\n                if (isFunction) {\r\n                    args[0] = value.call(this, index, self.html());\r\n                }\r\n                domManip(self, args, callback, ignored);\r\n            });\r\n        }\r\n        if (l) {\r\n            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\r\n            first = fragment.firstChild;\r\n            if (fragment.childNodes.length === 1) {\r\n                fragment = first;\r\n            }\r\n            // Require either new content or an interest in ignored elements to invoke the callback\r\n            if (first || ignored) {\r\n                scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\r\n                hasScripts = scripts.length;\r\n                // Use the original fragment for the last item\r\n                // instead of the first because it can end up\r\n                // being emptied incorrectly in certain situations (#8070).\r\n                for (; i < l; i++) {\r\n                    node = fragment;\r\n                    if (i !== iNoClone) {\r\n                        node = jQuery.clone(node, true, true);\r\n                        // Keep references to cloned scripts for later restoration\r\n                        if (hasScripts) {\r\n                            // Support: Android <=4.0 only, PhantomJS 1 only\r\n                            // push.apply(_, arraylike) throws on ancient WebKit\r\n                            jQuery.merge(scripts, getAll(node, \"script\"));\r\n                        }\r\n                    }\r\n                    callback.call(collection[i], node, i);\r\n                }\r\n                if (hasScripts) {\r\n                    doc = scripts[scripts.length - 1].ownerDocument;\r\n                    // Reenable scripts\r\n                    jQuery.map(scripts, restoreScript);\r\n                    // Evaluate executable scripts on first document insertion\r\n                    for (i = 0; i < hasScripts; i++) {\r\n                        node = scripts[i];\r\n                        if (rscriptType.test(node.type || \"\") &&\r\n                            !dataPriv.access(node, \"globalEval\") &&\r\n                            jQuery.contains(doc, node)) {\r\n                            if (node.src) {\r\n                                // Optional AJAX dependency, but won't run scripts if not present\r\n                                if (jQuery._evalUrl) {\r\n                                    jQuery._evalUrl(node.src);\r\n                                }\r\n                            }\r\n                            else {\r\n                                DOMEval(node.textContent.replace(rcleanScript, \"\"), doc);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return collection;\r\n    }\r\n    function remove(elem, selector, keepData) {\r\n        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;\r\n        for (; (node = nodes[i]) != null; i++) {\r\n            if (!keepData && node.nodeType === 1) {\r\n                jQuery.cleanData(getAll(node));\r\n            }\r\n            if (node.parentNode) {\r\n                if (keepData && jQuery.contains(node.ownerDocument, node)) {\r\n                    setGlobalEval(getAll(node, \"script\"));\r\n                }\r\n                node.parentNode.removeChild(node);\r\n            }\r\n        }\r\n        return elem;\r\n    }\r\n    jQuery.extend({\r\n        htmlPrefilter: function (html) {\r\n            return html.replace(rxhtmlTag, \"<$1></$2>\");\r\n        },\r\n        clone: function (elem, dataAndEvents, deepDataAndEvents) {\r\n            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);\r\n            // Fix IE cloning issues\r\n            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&\r\n                !jQuery.isXMLDoc(elem)) {\r\n                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\r\n                destElements = getAll(clone);\r\n                srcElements = getAll(elem);\r\n                for (i = 0, l = srcElements.length; i < l; i++) {\r\n                    fixInput(srcElements[i], destElements[i]);\r\n                }\r\n            }\r\n            // Copy the events from the original to the clone\r\n            if (dataAndEvents) {\r\n                if (deepDataAndEvents) {\r\n                    srcElements = srcElements || getAll(elem);\r\n                    destElements = destElements || getAll(clone);\r\n                    for (i = 0, l = srcElements.length; i < l; i++) {\r\n                        cloneCopyEvent(srcElements[i], destElements[i]);\r\n                    }\r\n                }\r\n                else {\r\n                    cloneCopyEvent(elem, clone);\r\n                }\r\n            }\r\n            // Preserve script evaluation history\r\n            destElements = getAll(clone, \"script\");\r\n            if (destElements.length > 0) {\r\n                setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\r\n            }\r\n            // Return the cloned set\r\n            return clone;\r\n        },\r\n        cleanData: function (elems) {\r\n            var data, elem, type, special = jQuery.event.special, i = 0;\r\n            for (; (elem = elems[i]) !== undefined; i++) {\r\n                if (acceptData(elem)) {\r\n                    if ((data = elem[dataPriv.expando])) {\r\n                        if (data.events) {\r\n                            for (type in data.events) {\r\n                                if (special[type]) {\r\n                                    jQuery.event.remove(elem, type);\r\n                                }\r\n                                else {\r\n                                    jQuery.removeEvent(elem, type, data.handle);\r\n                                }\r\n                            }\r\n                        }\r\n                        // Support: Chrome <=35 - 45+\r\n                        // Assign undefined instead of using delete, see Data#remove\r\n                        elem[dataPriv.expando] = undefined;\r\n                    }\r\n                    if (elem[dataUser.expando]) {\r\n                        // Support: Chrome <=35 - 45+\r\n                        // Assign undefined instead of using delete, see Data#remove\r\n                        elem[dataUser.expando] = undefined;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n    jQuery.fn.extend({\r\n        detach: function (selector) {\r\n            return remove(this, selector, true);\r\n        },\r\n        remove: function (selector) {\r\n            return remove(this, selector);\r\n        },\r\n        text: function (value) {\r\n            return access(this, function (value) {\r\n                return value === undefined ?\r\n                    jQuery.text(this) :\r\n                    this.empty().each(function () {\r\n                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\r\n                            this.textContent = value;\r\n                        }\r\n                    });\r\n            }, null, value, arguments.length);\r\n        },\r\n        append: function () {\r\n            return domManip(this, arguments, function (elem) {\r\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\r\n                    var target = manipulationTarget(this, elem);\r\n                    target.appendChild(elem);\r\n                }\r\n            });\r\n        },\r\n        prepend: function () {\r\n            return domManip(this, arguments, function (elem) {\r\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\r\n                    var target = manipulationTarget(this, elem);\r\n                    target.insertBefore(elem, target.firstChild);\r\n                }\r\n            });\r\n        },\r\n        before: function () {\r\n            return domManip(this, arguments, function (elem) {\r\n                if (this.parentNode) {\r\n                    this.parentNode.insertBefore(elem, this);\r\n                }\r\n            });\r\n        },\r\n        after: function () {\r\n            return domManip(this, arguments, function (elem) {\r\n                if (this.parentNode) {\r\n                    this.parentNode.insertBefore(elem, this.nextSibling);\r\n                }\r\n            });\r\n        },\r\n        empty: function () {\r\n            var elem, i = 0;\r\n            for (; (elem = this[i]) != null; i++) {\r\n                if (elem.nodeType === 1) {\r\n                    // Prevent memory leaks\r\n                    jQuery.cleanData(getAll(elem, false));\r\n                    // Remove any remaining nodes\r\n                    elem.textContent = \"\";\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        clone: function (dataAndEvents, deepDataAndEvents) {\r\n            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\r\n            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\r\n            return this.map(function () {\r\n                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\r\n            });\r\n        },\r\n        html: function (value) {\r\n            return access(this, function (value) {\r\n                var elem = this[0] || {}, i = 0, l = this.length;\r\n                if (value === undefined && elem.nodeType === 1) {\r\n                    return elem.innerHTML;\r\n                }\r\n                // See if we can take a shortcut and just use innerHTML\r\n                if (typeof value === \"string\" && !rnoInnerhtml.test(value) &&\r\n                    !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\r\n                    value = jQuery.htmlPrefilter(value);\r\n                    try {\r\n                        for (; i < l; i++) {\r\n                            elem = this[i] || {};\r\n                            // Remove element nodes and prevent memory leaks\r\n                            if (elem.nodeType === 1) {\r\n                                jQuery.cleanData(getAll(elem, false));\r\n                                elem.innerHTML = value;\r\n                            }\r\n                        }\r\n                        elem = 0;\r\n                    }\r\n                    catch (e) { }\r\n                }\r\n                if (elem) {\r\n                    this.empty().append(value);\r\n                }\r\n            }, null, value, arguments.length);\r\n        },\r\n        replaceWith: function () {\r\n            var ignored = [];\r\n            // Make the changes, replacing each non-ignored context element with the new content\r\n            return domManip(this, arguments, function (elem) {\r\n                var parent = this.parentNode;\r\n                if (jQuery.inArray(this, ignored) < 0) {\r\n                    jQuery.cleanData(getAll(this));\r\n                    if (parent) {\r\n                        parent.replaceChild(elem, this);\r\n                    }\r\n                }\r\n                // Force callback invocation\r\n            }, ignored);\r\n        }\r\n    });\r\n    jQuery.each({\r\n        appendTo: \"append\",\r\n        prependTo: \"prepend\",\r\n        insertBefore: \"before\",\r\n        insertAfter: \"after\",\r\n        replaceAll: \"replaceWith\"\r\n    }, function (name, original) {\r\n        jQuery.fn[name] = function (selector) {\r\n            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;\r\n            for (; i <= last; i++) {\r\n                elems = i === last ? this : this.clone(true);\r\n                jQuery(insert[i])[original](elems);\r\n                // Support: Android <=4.0 only, PhantomJS 1 only\r\n                // .get() because push.apply(_, arraylike) throws on ancient WebKit\r\n                push.apply(ret, elems.get());\r\n            }\r\n            return this.pushStack(ret);\r\n        };\r\n    });\r\n    var rmargin = (/^margin/);\r\n    var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\r\n    var getStyles = function (elem) {\r\n        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\r\n        // IE throws on elements created in popups\r\n        // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\r\n        var view = elem.ownerDocument.defaultView;\r\n        if (!view || !view.opener) {\r\n            view = window;\r\n        }\r\n        return view.getComputedStyle(elem);\r\n    };\r\n    (function () {\r\n        // Executing both pixelPosition & boxSizingReliable tests require only one layout\r\n        // so they're executed at the same time to save the second computation.\r\n        function computeStyleTests() {\r\n            // This is a singleton, we need to execute it only once\r\n            if (!div) {\r\n                return;\r\n            }\r\n            div.style.cssText =\r\n                \"box-sizing:border-box;\" +\r\n                    \"position:relative;display:block;\" +\r\n                    \"margin:auto;border:1px;padding:1px;\" +\r\n                    \"top:1%;width:50%\";\r\n            div.innerHTML = \"\";\r\n            documentElement.appendChild(container);\r\n            var divStyle = window.getComputedStyle(div);\r\n            pixelPositionVal = divStyle.top !== \"1%\";\r\n            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\r\n            reliableMarginLeftVal = divStyle.marginLeft === \"2px\";\r\n            boxSizingReliableVal = divStyle.width === \"4px\";\r\n            // Support: Android 4.0 - 4.3 only\r\n            // Some styles come back with percentage values, even though they shouldn't\r\n            div.style.marginRight = \"50%\";\r\n            pixelMarginRightVal = divStyle.marginRight === \"4px\";\r\n            documentElement.removeChild(container);\r\n            // Nullify the div so it wouldn't be stored in the memory and\r\n            // it will also be a sign that checks already performed\r\n            div = null;\r\n        }\r\n        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement(\"div\"), div = document.createElement(\"div\");\r\n        // Finish early in limited (non-browser) environments\r\n        if (!div.style) {\r\n            return;\r\n        }\r\n        // Support: IE <=9 - 11 only\r\n        // Style of cloned element affects source element cloned (#8908)\r\n        div.style.backgroundClip = \"content-box\";\r\n        div.cloneNode(true).style.backgroundClip = \"\";\r\n        support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\r\n        container.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\r\n            \"padding:0;margin-top:1px;position:absolute\";\r\n        container.appendChild(div);\r\n        jQuery.extend(support, {\r\n            pixelPosition: function () {\r\n                computeStyleTests();\r\n                return pixelPositionVal;\r\n            },\r\n            boxSizingReliable: function () {\r\n                computeStyleTests();\r\n                return boxSizingReliableVal;\r\n            },\r\n            pixelMarginRight: function () {\r\n                computeStyleTests();\r\n                return pixelMarginRightVal;\r\n            },\r\n            reliableMarginLeft: function () {\r\n                computeStyleTests();\r\n                return reliableMarginLeftVal;\r\n            }\r\n        });\r\n    })();\r\n    function curCSS(elem, name, computed) {\r\n        var width, minWidth, maxWidth, ret, style = elem.style;\r\n        computed = computed || getStyles(elem);\r\n        // Support: IE <=9 only\r\n        // getPropertyValue is only needed for .css('filter') (#12537)\r\n        if (computed) {\r\n            ret = computed.getPropertyValue(name) || computed[name];\r\n            if (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\r\n                ret = jQuery.style(elem, name);\r\n            }\r\n            // A tribute to the \"awesome hack by Dean Edwards\"\r\n            // Android Browser returns percentage for some values,\r\n            // but width seems to be reliably pixels.\r\n            // This is against the CSSOM draft spec:\r\n            // https://drafts.csswg.org/cssom/#resolved-values\r\n            if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {\r\n                // Remember the original values\r\n                width = style.width;\r\n                minWidth = style.minWidth;\r\n                maxWidth = style.maxWidth;\r\n                // Put in the new values to get a computed value out\r\n                style.minWidth = style.maxWidth = style.width = ret;\r\n                ret = computed.width;\r\n                // Revert the changed values\r\n                style.width = width;\r\n                style.minWidth = minWidth;\r\n                style.maxWidth = maxWidth;\r\n            }\r\n        }\r\n        return ret !== undefined ?\r\n            // Support: IE <=9 - 11 only\r\n            // IE returns zIndex value as an integer.\r\n            ret + \"\" :\r\n            ret;\r\n    }\r\n    function addGetHookIf(conditionFn, hookFn) {\r\n        // Define the hook, we'll check on the first run if it's really needed.\r\n        return {\r\n            get: function () {\r\n                if (conditionFn()) {\r\n                    // Hook not needed (or it's not possible to use it due\r\n                    // to missing dependency), remove it.\r\n                    delete this.get;\r\n                    return;\r\n                }\r\n                // Hook needed; redefine it so that the support test is not executed again.\r\n                return (this.get = hookFn).apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n    var \r\n    // Swappable if display is none or starts with table\r\n    // except \"table\", \"table-cell\", or \"table-caption\"\r\n    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\r\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" }, cssNormalTransform = {\r\n        letterSpacing: \"0\",\r\n        fontWeight: \"400\"\r\n    }, cssPrefixes = [\"Webkit\", \"Moz\", \"ms\"], emptyStyle = document.createElement(\"div\").style;\r\n    // Return a css property mapped to a potentially vendor prefixed property\r\n    function vendorPropName(name) {\r\n        // Shortcut for names that are not vendor prefixed\r\n        if (name in emptyStyle) {\r\n            return name;\r\n        }\r\n        // Check for vendor prefixed names\r\n        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;\r\n        while (i--) {\r\n            name = cssPrefixes[i] + capName;\r\n            if (name in emptyStyle) {\r\n                return name;\r\n            }\r\n        }\r\n    }\r\n    function setPositiveNumber(elem, value, subtract) {\r\n        // Any relative (+/-) values have already been\r\n        // normalized at this point\r\n        var matches = rcssNum.exec(value);\r\n        return matches ?\r\n            // Guard against undefined \"subtract\", e.g., when used as in cssHooks\r\n            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") :\r\n            value;\r\n    }\r\n    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\r\n        var i, val = 0;\r\n        // If we already have the right measurement, avoid augmentation\r\n        if (extra === (isBorderBox ? \"border\" : \"content\")) {\r\n            i = 4;\r\n        }\r\n        else {\r\n            i = name === \"width\" ? 1 : 0;\r\n        }\r\n        for (; i < 4; i += 2) {\r\n            // Both box models exclude margin, so add it if we want it\r\n            if (extra === \"margin\") {\r\n                val += jQuery.css(elem, extra + cssExpand[i], true, styles);\r\n            }\r\n            if (isBorderBox) {\r\n                // border-box includes padding, so remove it if we want content\r\n                if (extra === \"content\") {\r\n                    val -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\r\n                }\r\n                // At this point, extra isn't border nor margin, so remove border\r\n                if (extra !== \"margin\") {\r\n                    val -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\r\n                }\r\n            }\r\n            else {\r\n                // At this point, extra isn't content, so add padding\r\n                val += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\r\n                // At this point, extra isn't content nor padding, so add border\r\n                if (extra !== \"padding\") {\r\n                    val += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\r\n                }\r\n            }\r\n        }\r\n        return val;\r\n    }\r\n    function getWidthOrHeight(elem, name, extra) {\r\n        // Start with offset property, which is equivalent to the border-box value\r\n        var val, valueIsBorderBox = true, styles = getStyles(elem), isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\";\r\n        // Support: IE <=11 only\r\n        // Running getBoundingClientRect on a disconnected node\r\n        // in IE throws an error.\r\n        if (elem.getClientRects().length) {\r\n            val = elem.getBoundingClientRect()[name];\r\n        }\r\n        // Some non-html elements return undefined for offsetWidth, so check for null/undefined\r\n        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\r\n        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\r\n        if (val <= 0 || val == null) {\r\n            // Fall back to computed then uncomputed css if necessary\r\n            val = curCSS(elem, name, styles);\r\n            if (val < 0 || val == null) {\r\n                val = elem.style[name];\r\n            }\r\n            // Computed unit is not pixels. Stop here and return.\r\n            if (rnumnonpx.test(val)) {\r\n                return val;\r\n            }\r\n            // Check for style in case a browser which returns unreliable values\r\n            // for getComputedStyle silently falls back to the reliable elem.style\r\n            valueIsBorderBox = isBorderBox &&\r\n                (support.boxSizingReliable() || val === elem.style[name]);\r\n            // Normalize \"\", auto, and prepare for extra\r\n            val = parseFloat(val) || 0;\r\n        }\r\n        // Use the active box-sizing model to add/subtract irrelevant styles\r\n        return (val +\r\n            augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles)) + \"px\";\r\n    }\r\n    jQuery.extend({\r\n        // Add in style property hooks for overriding the default\r\n        // behavior of getting and setting a style property\r\n        cssHooks: {\r\n            opacity: {\r\n                get: function (elem, computed) {\r\n                    if (computed) {\r\n                        // We should always get a number back from opacity\r\n                        var ret = curCSS(elem, \"opacity\");\r\n                        return ret === \"\" ? \"1\" : ret;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        // Don't automatically add \"px\" to these possibly-unitless properties\r\n        cssNumber: {\r\n            \"animationIterationCount\": true,\r\n            \"columnCount\": true,\r\n            \"fillOpacity\": true,\r\n            \"flexGrow\": true,\r\n            \"flexShrink\": true,\r\n            \"fontWeight\": true,\r\n            \"lineHeight\": true,\r\n            \"opacity\": true,\r\n            \"order\": true,\r\n            \"orphans\": true,\r\n            \"widows\": true,\r\n            \"zIndex\": true,\r\n            \"zoom\": true\r\n        },\r\n        // Add in properties whose names you wish to fix before\r\n        // setting or getting the value\r\n        cssProps: {\r\n            \"float\": \"cssFloat\"\r\n        },\r\n        // Get and set the style property on a DOM Node\r\n        style: function (elem, name, value, extra) {\r\n            // Don't set styles on text and comment nodes\r\n            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\r\n                return;\r\n            }\r\n            // Make sure that we're working with the right name\r\n            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;\r\n            name = jQuery.cssProps[origName] ||\r\n                (jQuery.cssProps[origName] = vendorPropName(origName) || origName);\r\n            // Gets hook for the prefixed version, then unprefixed version\r\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\r\n            // Check if we're setting a value\r\n            if (value !== undefined) {\r\n                type = typeof value;\r\n                // Convert \"+=\" or \"-=\" to relative numbers (#7345)\r\n                if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\r\n                    value = adjustCSS(elem, name, ret);\r\n                    // Fixes bug #9237\r\n                    type = \"number\";\r\n                }\r\n                // Make sure that null and NaN values aren't set (#7116)\r\n                if (value == null || value !== value) {\r\n                    return;\r\n                }\r\n                // If a number was passed in, add the unit (except for certain CSS properties)\r\n                if (type === \"number\") {\r\n                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\r\n                }\r\n                // background-* props affect original clone's values\r\n                if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\r\n                    style[name] = \"inherit\";\r\n                }\r\n                // If a hook was provided, use that value, otherwise just set the specified value\r\n                if (!hooks || !(\"set\" in hooks) ||\r\n                    (value = hooks.set(elem, value, extra)) !== undefined) {\r\n                    style[name] = value;\r\n                }\r\n            }\r\n            else {\r\n                // If a hook was provided get the non-computed value from there\r\n                if (hooks && \"get\" in hooks &&\r\n                    (ret = hooks.get(elem, false, extra)) !== undefined) {\r\n                    return ret;\r\n                }\r\n                // Otherwise just get the value from the style object\r\n                return style[name];\r\n            }\r\n        },\r\n        css: function (elem, name, extra, styles) {\r\n            var val, num, hooks, origName = jQuery.camelCase(name);\r\n            // Make sure that we're working with the right name\r\n            name = jQuery.cssProps[origName] ||\r\n                (jQuery.cssProps[origName] = vendorPropName(origName) || origName);\r\n            // Try prefixed name followed by the unprefixed name\r\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\r\n            // If a hook was provided get the computed value from there\r\n            if (hooks && \"get\" in hooks) {\r\n                val = hooks.get(elem, true, extra);\r\n            }\r\n            // Otherwise, if a way to get the computed value exists, use that\r\n            if (val === undefined) {\r\n                val = curCSS(elem, name, styles);\r\n            }\r\n            // Convert \"normal\" to computed value\r\n            if (val === \"normal\" && name in cssNormalTransform) {\r\n                val = cssNormalTransform[name];\r\n            }\r\n            // Make numeric if forced or a qualifier was provided and val looks numeric\r\n            if (extra === \"\" || extra) {\r\n                num = parseFloat(val);\r\n                return extra === true || isFinite(num) ? num || 0 : val;\r\n            }\r\n            return val;\r\n        }\r\n    });\r\n    jQuery.each([\"height\", \"width\"], function (i, name) {\r\n        jQuery.cssHooks[name] = {\r\n            get: function (elem, computed, extra) {\r\n                if (computed) {\r\n                    // Certain elements can have dimension info if we invisibly show them\r\n                    // but it must have a current display style that would benefit\r\n                    return rdisplayswap.test(jQuery.css(elem, \"display\")) &&\r\n                        // Support: Safari 8+\r\n                        // Table columns in Safari have non-zero offsetWidth & zero\r\n                        // getBoundingClientRect().width unless display is changed.\r\n                        // Support: IE <=11 only\r\n                        // Running getBoundingClientRect on a disconnected node\r\n                        // in IE throws an error.\r\n                        (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?\r\n                        swap(elem, cssShow, function () {\r\n                            return getWidthOrHeight(elem, name, extra);\r\n                        }) :\r\n                        getWidthOrHeight(elem, name, extra);\r\n                }\r\n            },\r\n            set: function (elem, value, extra) {\r\n                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", styles);\r\n                // Convert to pixels if value adjustment is needed\r\n                if (subtract && (matches = rcssNum.exec(value)) &&\r\n                    (matches[3] || \"px\") !== \"px\") {\r\n                    elem.style[name] = value;\r\n                    value = jQuery.css(elem, name);\r\n                }\r\n                return setPositiveNumber(elem, value, subtract);\r\n            }\r\n        };\r\n    });\r\n    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\r\n        if (computed) {\r\n            return (parseFloat(curCSS(elem, \"marginLeft\")) ||\r\n                elem.getBoundingClientRect().left -\r\n                    swap(elem, { marginLeft: 0 }, function () {\r\n                        return elem.getBoundingClientRect().left;\r\n                    })) + \"px\";\r\n        }\r\n    });\r\n    // These hooks are used by animate to expand properties\r\n    jQuery.each({\r\n        margin: \"\",\r\n        padding: \"\",\r\n        border: \"Width\"\r\n    }, function (prefix, suffix) {\r\n        jQuery.cssHooks[prefix + suffix] = {\r\n            expand: function (value) {\r\n                var i = 0, expanded = {}, \r\n                // Assumes a single number if not a string\r\n                parts = typeof value === \"string\" ? value.split(\" \") : [value];\r\n                for (; i < 4; i++) {\r\n                    expanded[prefix + cssExpand[i] + suffix] =\r\n                        parts[i] || parts[i - 2] || parts[0];\r\n                }\r\n                return expanded;\r\n            }\r\n        };\r\n        if (!rmargin.test(prefix)) {\r\n            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\r\n        }\r\n    });\r\n    jQuery.fn.extend({\r\n        css: function (name, value) {\r\n            return access(this, function (elem, name, value) {\r\n                var styles, len, map = {}, i = 0;\r\n                if (jQuery.isArray(name)) {\r\n                    styles = getStyles(elem);\r\n                    len = name.length;\r\n                    for (; i < len; i++) {\r\n                        map[name[i]] = jQuery.css(elem, name[i], false, styles);\r\n                    }\r\n                    return map;\r\n                }\r\n                return value !== undefined ?\r\n                    jQuery.style(elem, name, value) :\r\n                    jQuery.css(elem, name);\r\n            }, name, value, arguments.length > 1);\r\n        }\r\n    });\r\n    function Tween(elem, options, prop, end, easing) {\r\n        return new Tween.prototype.init(elem, options, prop, end, easing);\r\n    }\r\n    jQuery.Tween = Tween;\r\n    Tween.prototype = {\r\n        constructor: Tween,\r\n        init: function (elem, options, prop, end, easing, unit) {\r\n            this.elem = elem;\r\n            this.prop = prop;\r\n            this.easing = easing || jQuery.easing._default;\r\n            this.options = options;\r\n            this.start = this.now = this.cur();\r\n            this.end = end;\r\n            this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\r\n        },\r\n        cur: function () {\r\n            var hooks = Tween.propHooks[this.prop];\r\n            return hooks && hooks.get ?\r\n                hooks.get(this) :\r\n                Tween.propHooks._default.get(this);\r\n        },\r\n        run: function (percent) {\r\n            var eased, hooks = Tween.propHooks[this.prop];\r\n            if (this.options.duration) {\r\n                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\r\n            }\r\n            else {\r\n                this.pos = eased = percent;\r\n            }\r\n            this.now = (this.end - this.start) * eased + this.start;\r\n            if (this.options.step) {\r\n                this.options.step.call(this.elem, this.now, this);\r\n            }\r\n            if (hooks && hooks.set) {\r\n                hooks.set(this);\r\n            }\r\n            else {\r\n                Tween.propHooks._default.set(this);\r\n            }\r\n            return this;\r\n        }\r\n    };\r\n    Tween.prototype.init.prototype = Tween.prototype;\r\n    Tween.propHooks = {\r\n        _default: {\r\n            get: function (tween) {\r\n                var result;\r\n                // Use a property on the element directly when it is not a DOM element,\r\n                // or when there is no matching style property that exists.\r\n                if (tween.elem.nodeType !== 1 ||\r\n                    tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\r\n                    return tween.elem[tween.prop];\r\n                }\r\n                // Passing an empty string as a 3rd parameter to .css will automatically\r\n                // attempt a parseFloat and fallback to a string if the parse fails.\r\n                // Simple values such as \"10px\" are parsed to Float;\r\n                // complex values such as \"rotate(1rad)\" are returned as-is.\r\n                result = jQuery.css(tween.elem, tween.prop, \"\");\r\n                // Empty strings, null, undefined and \"auto\" are converted to 0.\r\n                return !result || result === \"auto\" ? 0 : result;\r\n            },\r\n            set: function (tween) {\r\n                // Use step hook for back compat.\r\n                // Use cssHook if its there.\r\n                // Use .style if available and use plain properties where available.\r\n                if (jQuery.fx.step[tween.prop]) {\r\n                    jQuery.fx.step[tween.prop](tween);\r\n                }\r\n                else if (tween.elem.nodeType === 1 &&\r\n                    (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||\r\n                        jQuery.cssHooks[tween.prop])) {\r\n                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\r\n                }\r\n                else {\r\n                    tween.elem[tween.prop] = tween.now;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // Support: IE <=9 only\r\n    // Panic based approach to setting things on disconnected nodes\r\n    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\r\n        set: function (tween) {\r\n            if (tween.elem.nodeType && tween.elem.parentNode) {\r\n                tween.elem[tween.prop] = tween.now;\r\n            }\r\n        }\r\n    };\r\n    jQuery.easing = {\r\n        linear: function (p) {\r\n            return p;\r\n        },\r\n        swing: function (p) {\r\n            return 0.5 - Math.cos(p * Math.PI) / 2;\r\n        },\r\n        _default: \"swing\"\r\n    };\r\n    jQuery.fx = Tween.prototype.init;\r\n    // Back compat <1.8 extension point\r\n    jQuery.fx.step = {};\r\n    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;\r\n    function raf() {\r\n        if (timerId) {\r\n            window.requestAnimationFrame(raf);\r\n            jQuery.fx.tick();\r\n        }\r\n    }\r\n    // Animations created synchronously will run synchronously\r\n    function createFxNow() {\r\n        window.setTimeout(function () {\r\n            fxNow = undefined;\r\n        });\r\n        return (fxNow = jQuery.now());\r\n    }\r\n    // Generate parameters to create a standard animation\r\n    function genFx(type, includeWidth) {\r\n        var which, i = 0, attrs = { height: type };\r\n        // If we include width, step value is 1 to do all cssExpand values,\r\n        // otherwise step value is 2 to skip over Left and Right\r\n        includeWidth = includeWidth ? 1 : 0;\r\n        for (; i < 4; i += 2 - includeWidth) {\r\n            which = cssExpand[i];\r\n            attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\r\n        }\r\n        if (includeWidth) {\r\n            attrs.opacity = attrs.width = type;\r\n        }\r\n        return attrs;\r\n    }\r\n    function createTween(value, prop, animation) {\r\n        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]), index = 0, length = collection.length;\r\n        for (; index < length; index++) {\r\n            if ((tween = collection[index].call(animation, prop, value))) {\r\n                // We're done with this property\r\n                return tween;\r\n            }\r\n        }\r\n    }\r\n    function defaultPrefilter(elem, props, opts) {\r\n        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = \"width\" in props || \"height\" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, \"fxshow\");\r\n        // Queue-skipping animations hijack the fx hooks\r\n        if (!opts.queue) {\r\n            hooks = jQuery._queueHooks(elem, \"fx\");\r\n            if (hooks.unqueued == null) {\r\n                hooks.unqueued = 0;\r\n                oldfire = hooks.empty.fire;\r\n                hooks.empty.fire = function () {\r\n                    if (!hooks.unqueued) {\r\n                        oldfire();\r\n                    }\r\n                };\r\n            }\r\n            hooks.unqueued++;\r\n            anim.always(function () {\r\n                // Ensure the complete handler is called before this completes\r\n                anim.always(function () {\r\n                    hooks.unqueued--;\r\n                    if (!jQuery.queue(elem, \"fx\").length) {\r\n                        hooks.empty.fire();\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        // Detect show/hide animations\r\n        for (prop in props) {\r\n            value = props[prop];\r\n            if (rfxtypes.test(value)) {\r\n                delete props[prop];\r\n                toggle = toggle || value === \"toggle\";\r\n                if (value === (hidden ? \"hide\" : \"show\")) {\r\n                    // Pretend to be hidden if this is a \"show\" and\r\n                    // there is still data from a stopped show/hide\r\n                    if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\r\n                        hidden = true;\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\r\n            }\r\n        }\r\n        // Bail out if this is a no-op like .hide().hide()\r\n        propTween = !jQuery.isEmptyObject(props);\r\n        if (!propTween && jQuery.isEmptyObject(orig)) {\r\n            return;\r\n        }\r\n        // Restrict \"overflow\" and \"display\" styles during box animations\r\n        if (isBox && elem.nodeType === 1) {\r\n            // Support: IE <=9 - 11, Edge 12 - 13\r\n            // Record all 3 overflow attributes because IE does not infer the shorthand\r\n            // from identically-valued overflowX and overflowY\r\n            opts.overflow = [style.overflow, style.overflowX, style.overflowY];\r\n            // Identify a display type, preferring old show/hide data over the CSS cascade\r\n            restoreDisplay = dataShow && dataShow.display;\r\n            if (restoreDisplay == null) {\r\n                restoreDisplay = dataPriv.get(elem, \"display\");\r\n            }\r\n            display = jQuery.css(elem, \"display\");\r\n            if (display === \"none\") {\r\n                if (restoreDisplay) {\r\n                    display = restoreDisplay;\r\n                }\r\n                else {\r\n                    // Get nonempty value(s) by temporarily forcing visibility\r\n                    showHide([elem], true);\r\n                    restoreDisplay = elem.style.display || restoreDisplay;\r\n                    display = jQuery.css(elem, \"display\");\r\n                    showHide([elem]);\r\n                }\r\n            }\r\n            // Animate inline elements as inline-block\r\n            if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\r\n                if (jQuery.css(elem, \"float\") === \"none\") {\r\n                    // Restore the original display value at the end of pure show/hide animations\r\n                    if (!propTween) {\r\n                        anim.done(function () {\r\n                            style.display = restoreDisplay;\r\n                        });\r\n                        if (restoreDisplay == null) {\r\n                            display = style.display;\r\n                            restoreDisplay = display === \"none\" ? \"\" : display;\r\n                        }\r\n                    }\r\n                    style.display = \"inline-block\";\r\n                }\r\n            }\r\n        }\r\n        if (opts.overflow) {\r\n            style.overflow = \"hidden\";\r\n            anim.always(function () {\r\n                style.overflow = opts.overflow[0];\r\n                style.overflowX = opts.overflow[1];\r\n                style.overflowY = opts.overflow[2];\r\n            });\r\n        }\r\n        // Implement show/hide animations\r\n        propTween = false;\r\n        for (prop in orig) {\r\n            // General show/hide setup for this element animation\r\n            if (!propTween) {\r\n                if (dataShow) {\r\n                    if (\"hidden\" in dataShow) {\r\n                        hidden = dataShow.hidden;\r\n                    }\r\n                }\r\n                else {\r\n                    dataShow = dataPriv.access(elem, \"fxshow\", { display: restoreDisplay });\r\n                }\r\n                // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\r\n                if (toggle) {\r\n                    dataShow.hidden = !hidden;\r\n                }\r\n                // Show elements before animating them\r\n                if (hidden) {\r\n                    showHide([elem], true);\r\n                }\r\n                /* eslint-disable no-loop-func */\r\n                anim.done(function () {\r\n                    /* eslint-enable no-loop-func */\r\n                    // The final step of a \"hide\" animation is actually hiding the element\r\n                    if (!hidden) {\r\n                        showHide([elem]);\r\n                    }\r\n                    dataPriv.remove(elem, \"fxshow\");\r\n                    for (prop in orig) {\r\n                        jQuery.style(elem, prop, orig[prop]);\r\n                    }\r\n                });\r\n            }\r\n            // Per-property setup\r\n            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\r\n            if (!(prop in dataShow)) {\r\n                dataShow[prop] = propTween.start;\r\n                if (hidden) {\r\n                    propTween.end = propTween.start;\r\n                    propTween.start = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function propFilter(props, specialEasing) {\r\n        var index, name, easing, value, hooks;\r\n        // camelCase, specialEasing and expand cssHook pass\r\n        for (index in props) {\r\n            name = jQuery.camelCase(index);\r\n            easing = specialEasing[name];\r\n            value = props[index];\r\n            if (jQuery.isArray(value)) {\r\n                easing = value[1];\r\n                value = props[index] = value[0];\r\n            }\r\n            if (index !== name) {\r\n                props[name] = value;\r\n                delete props[index];\r\n            }\r\n            hooks = jQuery.cssHooks[name];\r\n            if (hooks && \"expand\" in hooks) {\r\n                value = hooks.expand(value);\r\n                delete props[name];\r\n                // Not quite $.extend, this won't overwrite existing keys.\r\n                // Reusing 'index' because we have the correct \"name\"\r\n                for (index in value) {\r\n                    if (!(index in props)) {\r\n                        props[index] = value[index];\r\n                        specialEasing[index] = easing;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                specialEasing[name] = easing;\r\n            }\r\n        }\r\n    }\r\n    function Animation(elem, properties, options) {\r\n        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function () {\r\n            // Don't match elem in the :animated selector\r\n            delete tick.elem;\r\n        }), tick = function () {\r\n            if (stopped) {\r\n                return false;\r\n            }\r\n            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), \r\n            // Support: Android 2.3 only\r\n            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\r\n            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;\r\n            for (; index < length; index++) {\r\n                animation.tweens[index].run(percent);\r\n            }\r\n            deferred.notifyWith(elem, [animation, percent, remaining]);\r\n            if (percent < 1 && length) {\r\n                return remaining;\r\n            }\r\n            else {\r\n                deferred.resolveWith(elem, [animation]);\r\n                return false;\r\n            }\r\n        }, animation = deferred.promise({\r\n            elem: elem,\r\n            props: jQuery.extend({}, properties),\r\n            opts: jQuery.extend(true, {\r\n                specialEasing: {},\r\n                easing: jQuery.easing._default\r\n            }, options),\r\n            originalProperties: properties,\r\n            originalOptions: options,\r\n            startTime: fxNow || createFxNow(),\r\n            duration: options.duration,\r\n            tweens: [],\r\n            createTween: function (prop, end) {\r\n                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\r\n                animation.tweens.push(tween);\r\n                return tween;\r\n            },\r\n            stop: function (gotoEnd) {\r\n                var index = 0, \r\n                // If we are going to the end, we want to run all the tweens\r\n                // otherwise we skip this part\r\n                length = gotoEnd ? animation.tweens.length : 0;\r\n                if (stopped) {\r\n                    return this;\r\n                }\r\n                stopped = true;\r\n                for (; index < length; index++) {\r\n                    animation.tweens[index].run(1);\r\n                }\r\n                // Resolve when we played the last frame; otherwise, reject\r\n                if (gotoEnd) {\r\n                    deferred.notifyWith(elem, [animation, 1, 0]);\r\n                    deferred.resolveWith(elem, [animation, gotoEnd]);\r\n                }\r\n                else {\r\n                    deferred.rejectWith(elem, [animation, gotoEnd]);\r\n                }\r\n                return this;\r\n            }\r\n        }), props = animation.props;\r\n        propFilter(props, animation.opts.specialEasing);\r\n        for (; index < length; index++) {\r\n            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\r\n            if (result) {\r\n                if (jQuery.isFunction(result.stop)) {\r\n                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop =\r\n                        jQuery.proxy(result.stop, result);\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        jQuery.map(props, createTween, animation);\r\n        if (jQuery.isFunction(animation.opts.start)) {\r\n            animation.opts.start.call(elem, animation);\r\n        }\r\n        jQuery.fx.timer(jQuery.extend(tick, {\r\n            elem: elem,\r\n            anim: animation,\r\n            queue: animation.opts.queue\r\n        }));\r\n        // attach callbacks from options\r\n        return animation.progress(animation.opts.progress)\r\n            .done(animation.opts.done, animation.opts.complete)\r\n            .fail(animation.opts.fail)\r\n            .always(animation.opts.always);\r\n    }\r\n    jQuery.Animation = jQuery.extend(Animation, {\r\n        tweeners: {\r\n            \"*\": [function (prop, value) {\r\n                    var tween = this.createTween(prop, value);\r\n                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\r\n                    return tween;\r\n                }]\r\n        },\r\n        tweener: function (props, callback) {\r\n            if (jQuery.isFunction(props)) {\r\n                callback = props;\r\n                props = [\"*\"];\r\n            }\r\n            else {\r\n                props = props.match(rnothtmlwhite);\r\n            }\r\n            var prop, index = 0, length = props.length;\r\n            for (; index < length; index++) {\r\n                prop = props[index];\r\n                Animation.tweeners[prop] = Animation.tweeners[prop] || [];\r\n                Animation.tweeners[prop].unshift(callback);\r\n            }\r\n        },\r\n        prefilters: [defaultPrefilter],\r\n        prefilter: function (callback, prepend) {\r\n            if (prepend) {\r\n                Animation.prefilters.unshift(callback);\r\n            }\r\n            else {\r\n                Animation.prefilters.push(callback);\r\n            }\r\n        }\r\n    });\r\n    jQuery.speed = function (speed, easing, fn) {\r\n        var opt = speed && typeof speed === \"object\" ? jQuery.extend({}, speed) : {\r\n            complete: fn || !fn && easing ||\r\n                jQuery.isFunction(speed) && speed,\r\n            duration: speed,\r\n            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing\r\n        };\r\n        // Go to the end state if fx are off or if document is hidden\r\n        if (jQuery.fx.off || document.hidden) {\r\n            opt.duration = 0;\r\n        }\r\n        else {\r\n            if (typeof opt.duration !== \"number\") {\r\n                if (opt.duration in jQuery.fx.speeds) {\r\n                    opt.duration = jQuery.fx.speeds[opt.duration];\r\n                }\r\n                else {\r\n                    opt.duration = jQuery.fx.speeds._default;\r\n                }\r\n            }\r\n        }\r\n        // Normalize opt.queue - true/undefined/null -> \"fx\"\r\n        if (opt.queue == null || opt.queue === true) {\r\n            opt.queue = \"fx\";\r\n        }\r\n        // Queueing\r\n        opt.old = opt.complete;\r\n        opt.complete = function () {\r\n            if (jQuery.isFunction(opt.old)) {\r\n                opt.old.call(this);\r\n            }\r\n            if (opt.queue) {\r\n                jQuery.dequeue(this, opt.queue);\r\n            }\r\n        };\r\n        return opt;\r\n    };\r\n    jQuery.fn.extend({\r\n        fadeTo: function (speed, to, easing, callback) {\r\n            // Show any hidden elements after setting opacity to 0\r\n            return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show()\r\n                .end().animate({ opacity: to }, speed, easing, callback);\r\n        },\r\n        animate: function (prop, speed, easing, callback) {\r\n            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {\r\n                // Operate on a copy of prop so per-property easing won't be lost\r\n                var anim = Animation(this, jQuery.extend({}, prop), optall);\r\n                // Empty animations, or finishing resolves immediately\r\n                if (empty || dataPriv.get(this, \"finish\")) {\r\n                    anim.stop(true);\r\n                }\r\n            };\r\n            doAnimation.finish = doAnimation;\r\n            return empty || optall.queue === false ?\r\n                this.each(doAnimation) :\r\n                this.queue(optall.queue, doAnimation);\r\n        },\r\n        stop: function (type, clearQueue, gotoEnd) {\r\n            var stopQueue = function (hooks) {\r\n                var stop = hooks.stop;\r\n                delete hooks.stop;\r\n                stop(gotoEnd);\r\n            };\r\n            if (typeof type !== \"string\") {\r\n                gotoEnd = clearQueue;\r\n                clearQueue = type;\r\n                type = undefined;\r\n            }\r\n            if (clearQueue && type !== false) {\r\n                this.queue(type || \"fx\", []);\r\n            }\r\n            return this.each(function () {\r\n                var dequeue = true, index = type != null && type + \"queueHooks\", timers = jQuery.timers, data = dataPriv.get(this);\r\n                if (index) {\r\n                    if (data[index] && data[index].stop) {\r\n                        stopQueue(data[index]);\r\n                    }\r\n                }\r\n                else {\r\n                    for (index in data) {\r\n                        if (data[index] && data[index].stop && rrun.test(index)) {\r\n                            stopQueue(data[index]);\r\n                        }\r\n                    }\r\n                }\r\n                for (index = timers.length; index--;) {\r\n                    if (timers[index].elem === this &&\r\n                        (type == null || timers[index].queue === type)) {\r\n                        timers[index].anim.stop(gotoEnd);\r\n                        dequeue = false;\r\n                        timers.splice(index, 1);\r\n                    }\r\n                }\r\n                // Start the next in the queue if the last step wasn't forced.\r\n                // Timers currently will call their complete callbacks, which\r\n                // will dequeue but only if they were gotoEnd.\r\n                if (dequeue || !gotoEnd) {\r\n                    jQuery.dequeue(this, type);\r\n                }\r\n            });\r\n        },\r\n        finish: function (type) {\r\n            if (type !== false) {\r\n                type = type || \"fx\";\r\n            }\r\n            return this.each(function () {\r\n                var index, data = dataPriv.get(this), queue = data[type + \"queue\"], hooks = data[type + \"queueHooks\"], timers = jQuery.timers, length = queue ? queue.length : 0;\r\n                // Enable finishing flag on private data\r\n                data.finish = true;\r\n                // Empty the queue first\r\n                jQuery.queue(this, type, []);\r\n                if (hooks && hooks.stop) {\r\n                    hooks.stop.call(this, true);\r\n                }\r\n                // Look for any active animations, and finish them\r\n                for (index = timers.length; index--;) {\r\n                    if (timers[index].elem === this && timers[index].queue === type) {\r\n                        timers[index].anim.stop(true);\r\n                        timers.splice(index, 1);\r\n                    }\r\n                }\r\n                // Look for any animations in the old queue and finish them\r\n                for (index = 0; index < length; index++) {\r\n                    if (queue[index] && queue[index].finish) {\r\n                        queue[index].finish.call(this);\r\n                    }\r\n                }\r\n                // Turn off finishing flag\r\n                delete data.finish;\r\n            });\r\n        }\r\n    });\r\n    jQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\r\n        var cssFn = jQuery.fn[name];\r\n        jQuery.fn[name] = function (speed, easing, callback) {\r\n            return speed == null || typeof speed === \"boolean\" ?\r\n                cssFn.apply(this, arguments) :\r\n                this.animate(genFx(name, true), speed, easing, callback);\r\n        };\r\n    });\r\n    // Generate shortcuts for custom animations\r\n    jQuery.each({\r\n        slideDown: genFx(\"show\"),\r\n        slideUp: genFx(\"hide\"),\r\n        slideToggle: genFx(\"toggle\"),\r\n        fadeIn: { opacity: \"show\" },\r\n        fadeOut: { opacity: \"hide\" },\r\n        fadeToggle: { opacity: \"toggle\" }\r\n    }, function (name, props) {\r\n        jQuery.fn[name] = function (speed, easing, callback) {\r\n            return this.animate(props, speed, easing, callback);\r\n        };\r\n    });\r\n    jQuery.timers = [];\r\n    jQuery.fx.tick = function () {\r\n        var timer, i = 0, timers = jQuery.timers;\r\n        fxNow = jQuery.now();\r\n        for (; i < timers.length; i++) {\r\n            timer = timers[i];\r\n            // Checks the timer has not already been removed\r\n            if (!timer() && timers[i] === timer) {\r\n                timers.splice(i--, 1);\r\n            }\r\n        }\r\n        if (!timers.length) {\r\n            jQuery.fx.stop();\r\n        }\r\n        fxNow = undefined;\r\n    };\r\n    jQuery.fx.timer = function (timer) {\r\n        jQuery.timers.push(timer);\r\n        if (timer()) {\r\n            jQuery.fx.start();\r\n        }\r\n        else {\r\n            jQuery.timers.pop();\r\n        }\r\n    };\r\n    jQuery.fx.interval = 13;\r\n    jQuery.fx.start = function () {\r\n        if (!timerId) {\r\n            timerId = window.requestAnimationFrame ?\r\n                window.requestAnimationFrame(raf) :\r\n                window.setInterval(jQuery.fx.tick, jQuery.fx.interval);\r\n        }\r\n    };\r\n    jQuery.fx.stop = function () {\r\n        if (window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(timerId);\r\n        }\r\n        else {\r\n            window.clearInterval(timerId);\r\n        }\r\n        timerId = null;\r\n    };\r\n    jQuery.fx.speeds = {\r\n        slow: 600,\r\n        fast: 200,\r\n        // Default speed\r\n        _default: 400\r\n    };\r\n    // Based off of the plugin by Clint Helfers, with permission.\r\n    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\r\n    jQuery.fn.delay = function (time, type) {\r\n        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\r\n        type = type || \"fx\";\r\n        return this.queue(type, function (next, hooks) {\r\n            var timeout = window.setTimeout(next, time);\r\n            hooks.stop = function () {\r\n                window.clearTimeout(timeout);\r\n            };\r\n        });\r\n    };\r\n    (function () {\r\n        var input = document.createElement(\"input\"), select = document.createElement(\"select\"), opt = select.appendChild(document.createElement(\"option\"));\r\n        input.type = \"checkbox\";\r\n        // Support: Android <=4.3 only\r\n        // Default value for a checkbox should be \"on\"\r\n        support.checkOn = input.value !== \"\";\r\n        // Support: IE <=11 only\r\n        // Must access selectedIndex to make default options select\r\n        support.optSelected = opt.selected;\r\n        // Support: IE <=11 only\r\n        // An input loses its value after becoming a radio\r\n        input = document.createElement(\"input\");\r\n        input.value = \"t\";\r\n        input.type = \"radio\";\r\n        support.radioValue = input.value === \"t\";\r\n    })();\r\n    var boolHook, attrHandle = jQuery.expr.attrHandle;\r\n    jQuery.fn.extend({\r\n        attr: function (name, value) {\r\n            return access(this, jQuery.attr, name, value, arguments.length > 1);\r\n        },\r\n        removeAttr: function (name) {\r\n            return this.each(function () {\r\n                jQuery.removeAttr(this, name);\r\n            });\r\n        }\r\n    });\r\n    jQuery.extend({\r\n        attr: function (elem, name, value) {\r\n            var ret, hooks, nType = elem.nodeType;\r\n            // Don't get/set attributes on text, comment and attribute nodes\r\n            if (nType === 3 || nType === 8 || nType === 2) {\r\n                return;\r\n            }\r\n            // Fallback to prop when attributes are not supported\r\n            if (typeof elem.getAttribute === \"undefined\") {\r\n                return jQuery.prop(elem, name, value);\r\n            }\r\n            // Attribute hooks are determined by the lowercase version\r\n            // Grab necessary hook if one is defined\r\n            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\r\n                hooks = jQuery.attrHooks[name.toLowerCase()] ||\r\n                    (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\r\n            }\r\n            if (value !== undefined) {\r\n                if (value === null) {\r\n                    jQuery.removeAttr(elem, name);\r\n                    return;\r\n                }\r\n                if (hooks && \"set\" in hooks &&\r\n                    (ret = hooks.set(elem, value, name)) !== undefined) {\r\n                    return ret;\r\n                }\r\n                elem.setAttribute(name, value + \"\");\r\n                return value;\r\n            }\r\n            if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\r\n                return ret;\r\n            }\r\n            ret = jQuery.find.attr(elem, name);\r\n            // Non-existent attributes return null, we normalize to undefined\r\n            return ret == null ? undefined : ret;\r\n        },\r\n        attrHooks: {\r\n            type: {\r\n                set: function (elem, value) {\r\n                    if (!support.radioValue && value === \"radio\" &&\r\n                        jQuery.nodeName(elem, \"input\")) {\r\n                        var val = elem.value;\r\n                        elem.setAttribute(\"type\", value);\r\n                        if (val) {\r\n                            elem.value = val;\r\n                        }\r\n                        return value;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        removeAttr: function (elem, value) {\r\n            var name, i = 0, \r\n            // Attribute names can contain non-HTML whitespace characters\r\n            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\r\n            attrNames = value && value.match(rnothtmlwhite);\r\n            if (attrNames && elem.nodeType === 1) {\r\n                while ((name = attrNames[i++])) {\r\n                    elem.removeAttribute(name);\r\n                }\r\n            }\r\n        }\r\n    });\r\n    // Hooks for boolean attributes\r\n    boolHook = {\r\n        set: function (elem, value, name) {\r\n            if (value === false) {\r\n                // Remove boolean attributes when set to false\r\n                jQuery.removeAttr(elem, name);\r\n            }\r\n            else {\r\n                elem.setAttribute(name, name);\r\n            }\r\n            return name;\r\n        }\r\n    };\r\n    jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\r\n        var getter = attrHandle[name] || jQuery.find.attr;\r\n        attrHandle[name] = function (elem, name, isXML) {\r\n            var ret, handle, lowercaseName = name.toLowerCase();\r\n            if (!isXML) {\r\n                // Avoid an infinite loop by temporarily removing this function from the getter\r\n                handle = attrHandle[lowercaseName];\r\n                attrHandle[lowercaseName] = ret;\r\n                ret = getter(elem, name, isXML) != null ?\r\n                    lowercaseName :\r\n                    null;\r\n                attrHandle[lowercaseName] = handle;\r\n            }\r\n            return ret;\r\n        };\r\n    });\r\n    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;\r\n    jQuery.fn.extend({\r\n        prop: function (name, value) {\r\n            return access(this, jQuery.prop, name, value, arguments.length > 1);\r\n        },\r\n        removeProp: function (name) {\r\n            return this.each(function () {\r\n                delete this[jQuery.propFix[name] || name];\r\n            });\r\n        }\r\n    });\r\n    jQuery.extend({\r\n        prop: function (elem, name, value) {\r\n            var ret, hooks, nType = elem.nodeType;\r\n            // Don't get/set properties on text, comment and attribute nodes\r\n            if (nType === 3 || nType === 8 || nType === 2) {\r\n                return;\r\n            }\r\n            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\r\n                // Fix name and attach hooks\r\n                name = jQuery.propFix[name] || name;\r\n                hooks = jQuery.propHooks[name];\r\n            }\r\n            if (value !== undefined) {\r\n                if (hooks && \"set\" in hooks &&\r\n                    (ret = hooks.set(elem, value, name)) !== undefined) {\r\n                    return ret;\r\n                }\r\n                return (elem[name] = value);\r\n            }\r\n            if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\r\n                return ret;\r\n            }\r\n            return elem[name];\r\n        },\r\n        propHooks: {\r\n            tabIndex: {\r\n                get: function (elem) {\r\n                    // Support: IE <=9 - 11 only\r\n                    // elem.tabIndex doesn't always return the\r\n                    // correct value when it hasn't been explicitly set\r\n                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\r\n                    // Use proper attribute retrieval(#12072)\r\n                    var tabindex = jQuery.find.attr(elem, \"tabindex\");\r\n                    if (tabindex) {\r\n                        return parseInt(tabindex, 10);\r\n                    }\r\n                    if (rfocusable.test(elem.nodeName) ||\r\n                        rclickable.test(elem.nodeName) &&\r\n                            elem.href) {\r\n                        return 0;\r\n                    }\r\n                    return -1;\r\n                }\r\n            }\r\n        },\r\n        propFix: {\r\n            \"for\": \"htmlFor\",\r\n            \"class\": \"className\"\r\n        }\r\n    });\r\n    // Support: IE <=11 only\r\n    // Accessing the selectedIndex property\r\n    // forces the browser to respect setting selected\r\n    // on the option\r\n    // The getter ensures a default option is selected\r\n    // when in an optgroup\r\n    // eslint rule \"no-unused-expressions\" is disabled for this code\r\n    // since it considers such accessions noop\r\n    if (!support.optSelected) {\r\n        jQuery.propHooks.selected = {\r\n            get: function (elem) {\r\n                /* eslint no-unused-expressions: \"off\" */\r\n                var parent = elem.parentNode;\r\n                if (parent && parent.parentNode) {\r\n                    parent.parentNode.selectedIndex;\r\n                }\r\n                return null;\r\n            },\r\n            set: function (elem) {\r\n                /* eslint no-unused-expressions: \"off\" */\r\n                var parent = elem.parentNode;\r\n                if (parent) {\r\n                    parent.selectedIndex;\r\n                    if (parent.parentNode) {\r\n                        parent.parentNode.selectedIndex;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n    jQuery.each([\r\n        \"tabIndex\",\r\n        \"readOnly\",\r\n        \"maxLength\",\r\n        \"cellSpacing\",\r\n        \"cellPadding\",\r\n        \"rowSpan\",\r\n        \"colSpan\",\r\n        \"useMap\",\r\n        \"frameBorder\",\r\n        \"contentEditable\"\r\n    ], function () {\r\n        jQuery.propFix[this.toLowerCase()] = this;\r\n    });\r\n    // Strip and collapse whitespace according to HTML spec\r\n    // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\r\n    function stripAndCollapse(value) {\r\n        var tokens = value.match(rnothtmlwhite) || [];\r\n        return tokens.join(\" \");\r\n    }\r\n    function getClass(elem) {\r\n        return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\r\n    }\r\n    jQuery.fn.extend({\r\n        addClass: function (value) {\r\n            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;\r\n            if (jQuery.isFunction(value)) {\r\n                return this.each(function (j) {\r\n                    jQuery(this).addClass(value.call(this, j, getClass(this)));\r\n                });\r\n            }\r\n            if (typeof value === \"string\" && value) {\r\n                classes = value.match(rnothtmlwhite) || [];\r\n                while ((elem = this[i++])) {\r\n                    curValue = getClass(elem);\r\n                    cur = elem.nodeType === 1 && (\" \" + stripAndCollapse(curValue) + \" \");\r\n                    if (cur) {\r\n                        j = 0;\r\n                        while ((clazz = classes[j++])) {\r\n                            if (cur.indexOf(\" \" + clazz + \" \") < 0) {\r\n                                cur += clazz + \" \";\r\n                            }\r\n                        }\r\n                        // Only assign if different to avoid unneeded rendering.\r\n                        finalValue = stripAndCollapse(cur);\r\n                        if (curValue !== finalValue) {\r\n                            elem.setAttribute(\"class\", finalValue);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        removeClass: function (value) {\r\n            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;\r\n            if (jQuery.isFunction(value)) {\r\n                return this.each(function (j) {\r\n                    jQuery(this).removeClass(value.call(this, j, getClass(this)));\r\n                });\r\n            }\r\n            if (!arguments.length) {\r\n                return this.attr(\"class\", \"\");\r\n            }\r\n            if (typeof value === \"string\" && value) {\r\n                classes = value.match(rnothtmlwhite) || [];\r\n                while ((elem = this[i++])) {\r\n                    curValue = getClass(elem);\r\n                    // This expression is here for better compressibility (see addClass)\r\n                    cur = elem.nodeType === 1 && (\" \" + stripAndCollapse(curValue) + \" \");\r\n                    if (cur) {\r\n                        j = 0;\r\n                        while ((clazz = classes[j++])) {\r\n                            // Remove *all* instances\r\n                            while (cur.indexOf(\" \" + clazz + \" \") > -1) {\r\n                                cur = cur.replace(\" \" + clazz + \" \", \" \");\r\n                            }\r\n                        }\r\n                        // Only assign if different to avoid unneeded rendering.\r\n                        finalValue = stripAndCollapse(cur);\r\n                        if (curValue !== finalValue) {\r\n                            elem.setAttribute(\"class\", finalValue);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        toggleClass: function (value, stateVal) {\r\n            var type = typeof value;\r\n            if (typeof stateVal === \"boolean\" && type === \"string\") {\r\n                return stateVal ? this.addClass(value) : this.removeClass(value);\r\n            }\r\n            if (jQuery.isFunction(value)) {\r\n                return this.each(function (i) {\r\n                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\r\n                });\r\n            }\r\n            return this.each(function () {\r\n                var className, i, self, classNames;\r\n                if (type === \"string\") {\r\n                    // Toggle individual class names\r\n                    i = 0;\r\n                    self = jQuery(this);\r\n                    classNames = value.match(rnothtmlwhite) || [];\r\n                    while ((className = classNames[i++])) {\r\n                        // Check each className given, space separated list\r\n                        if (self.hasClass(className)) {\r\n                            self.removeClass(className);\r\n                        }\r\n                        else {\r\n                            self.addClass(className);\r\n                        }\r\n                    }\r\n                }\r\n                else if (value === undefined || type === \"boolean\") {\r\n                    className = getClass(this);\r\n                    if (className) {\r\n                        // Store className if set\r\n                        dataPriv.set(this, \"__className__\", className);\r\n                    }\r\n                    // If the element has a class name or if we're passed `false`,\r\n                    // then remove the whole classname (if there was one, the above saved it).\r\n                    // Otherwise bring back whatever was previously saved (if anything),\r\n                    // falling back to the empty string if nothing was stored.\r\n                    if (this.setAttribute) {\r\n                        this.setAttribute(\"class\", className || value === false ?\r\n                            \"\" :\r\n                            dataPriv.get(this, \"__className__\") || \"\");\r\n                    }\r\n                }\r\n            });\r\n        },\r\n        hasClass: function (selector) {\r\n            var className, elem, i = 0;\r\n            className = \" \" + selector + \" \";\r\n            while ((elem = this[i++])) {\r\n                if (elem.nodeType === 1 &&\r\n                    (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    });\r\n    var rreturn = /\\r/g;\r\n    jQuery.fn.extend({\r\n        val: function (value) {\r\n            var hooks, ret, isFunction, elem = this[0];\r\n            if (!arguments.length) {\r\n                if (elem) {\r\n                    hooks = jQuery.valHooks[elem.type] ||\r\n                        jQuery.valHooks[elem.nodeName.toLowerCase()];\r\n                    if (hooks &&\r\n                        \"get\" in hooks &&\r\n                        (ret = hooks.get(elem, \"value\")) !== undefined) {\r\n                        return ret;\r\n                    }\r\n                    ret = elem.value;\r\n                    // Handle most common string cases\r\n                    if (typeof ret === \"string\") {\r\n                        return ret.replace(rreturn, \"\");\r\n                    }\r\n                    // Handle cases where value is null/undef or number\r\n                    return ret == null ? \"\" : ret;\r\n                }\r\n                return;\r\n            }\r\n            isFunction = jQuery.isFunction(value);\r\n            return this.each(function (i) {\r\n                var val;\r\n                if (this.nodeType !== 1) {\r\n                    return;\r\n                }\r\n                if (isFunction) {\r\n                    val = value.call(this, i, jQuery(this).val());\r\n                }\r\n                else {\r\n                    val = value;\r\n                }\r\n                // Treat null/undefined as \"\"; convert numbers to string\r\n                if (val == null) {\r\n                    val = \"\";\r\n                }\r\n                else if (typeof val === \"number\") {\r\n                    val += \"\";\r\n                }\r\n                else if (jQuery.isArray(val)) {\r\n                    val = jQuery.map(val, function (value) {\r\n                        return value == null ? \"\" : value + \"\";\r\n                    });\r\n                }\r\n                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\r\n                // If set returns undefined, fall back to normal setting\r\n                if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\r\n                    this.value = val;\r\n                }\r\n            });\r\n        }\r\n    });\r\n    jQuery.extend({\r\n        valHooks: {\r\n            option: {\r\n                get: function (elem) {\r\n                    var val = jQuery.find.attr(elem, \"value\");\r\n                    return val != null ?\r\n                        val :\r\n                        // Support: IE <=10 - 11 only\r\n                        // option.text throws exceptions (#14686, #14858)\r\n                        // Strip and collapse whitespace\r\n                        // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\r\n                        stripAndCollapse(jQuery.text(elem));\r\n                }\r\n            },\r\n            select: {\r\n                get: function (elem) {\r\n                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === \"select-one\", values = one ? null : [], max = one ? index + 1 : options.length;\r\n                    if (index < 0) {\r\n                        i = max;\r\n                    }\r\n                    else {\r\n                        i = one ? index : 0;\r\n                    }\r\n                    // Loop through all the selected options\r\n                    for (; i < max; i++) {\r\n                        option = options[i];\r\n                        // Support: IE <=9 only\r\n                        // IE8-9 doesn't update selected after form reset (#2551)\r\n                        if ((option.selected || i === index) &&\r\n                            // Don't return options that are disabled or in a disabled optgroup\r\n                            !option.disabled &&\r\n                            (!option.parentNode.disabled ||\r\n                                !jQuery.nodeName(option.parentNode, \"optgroup\"))) {\r\n                            // Get the specific value for the option\r\n                            value = jQuery(option).val();\r\n                            // We don't need an array for one selects\r\n                            if (one) {\r\n                                return value;\r\n                            }\r\n                            // Multi-Selects return an array\r\n                            values.push(value);\r\n                        }\r\n                    }\r\n                    return values;\r\n                },\r\n                set: function (elem, value) {\r\n                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;\r\n                    while (i--) {\r\n                        option = options[i];\r\n                        /* eslint-disable no-cond-assign */\r\n                        if (option.selected =\r\n                            jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\r\n                            optionSet = true;\r\n                        }\r\n                    }\r\n                    // Force browsers to behave consistently when non-matching value is set\r\n                    if (!optionSet) {\r\n                        elem.selectedIndex = -1;\r\n                    }\r\n                    return values;\r\n                }\r\n            }\r\n        }\r\n    });\r\n    // Radios and checkboxes getter/setter\r\n    jQuery.each([\"radio\", \"checkbox\"], function () {\r\n        jQuery.valHooks[this] = {\r\n            set: function (elem, value) {\r\n                if (jQuery.isArray(value)) {\r\n                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);\r\n                }\r\n            }\r\n        };\r\n        if (!support.checkOn) {\r\n            jQuery.valHooks[this].get = function (elem) {\r\n                return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\r\n            };\r\n        }\r\n    });\r\n    // Return jQuery for attributes-only inclusion\r\n    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\r\n    jQuery.extend(jQuery.event, {\r\n        trigger: function (event, data, elem, onlyHandlers) {\r\n            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, \"type\") ? event.type : event, namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\r\n            cur = tmp = elem = elem || document;\r\n            // Don't do events on text and comment nodes\r\n            if (elem.nodeType === 3 || elem.nodeType === 8) {\r\n                return;\r\n            }\r\n            // focus/blur morphs to focusin/out; ensure we're not firing them right now\r\n            if (rfocusMorph.test(type + jQuery.event.triggered)) {\r\n                return;\r\n            }\r\n            if (type.indexOf(\".\") > -1) {\r\n                // Namespaced trigger; create a regexp to match event type in handle()\r\n                namespaces = type.split(\".\");\r\n                type = namespaces.shift();\r\n                namespaces.sort();\r\n            }\r\n            ontype = type.indexOf(\":\") < 0 && \"on\" + type;\r\n            // Caller can pass in a jQuery.Event object, Object, or just an event type string\r\n            event = event[jQuery.expando] ?\r\n                event :\r\n                new jQuery.Event(type, typeof event === \"object\" && event);\r\n            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\r\n            event.isTrigger = onlyHandlers ? 2 : 3;\r\n            event.namespace = namespaces.join(\".\");\r\n            event.rnamespace = event.namespace ?\r\n                new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") :\r\n                null;\r\n            // Clean up the event in case it is being reused\r\n            event.result = undefined;\r\n            if (!event.target) {\r\n                event.target = elem;\r\n            }\r\n            // Clone any incoming data and prepend the event, creating the handler arg list\r\n            data = data == null ?\r\n                [event] :\r\n                jQuery.makeArray(data, [event]);\r\n            // Allow special events to draw outside the lines\r\n            special = jQuery.event.special[type] || {};\r\n            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\r\n                return;\r\n            }\r\n            // Determine event propagation path in advance, per W3C events spec (#9951)\r\n            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\r\n            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\r\n                bubbleType = special.delegateType || type;\r\n                if (!rfocusMorph.test(bubbleType + type)) {\r\n                    cur = cur.parentNode;\r\n                }\r\n                for (; cur; cur = cur.parentNode) {\r\n                    eventPath.push(cur);\r\n                    tmp = cur;\r\n                }\r\n                // Only add window if we got to document (e.g., not plain obj or detached DOM)\r\n                if (tmp === (elem.ownerDocument || document)) {\r\n                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);\r\n                }\r\n            }\r\n            // Fire handlers on the event path\r\n            i = 0;\r\n            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\r\n                event.type = i > 1 ?\r\n                    bubbleType :\r\n                    special.bindType || type;\r\n                // jQuery handler\r\n                handle = (dataPriv.get(cur, \"events\") || {})[event.type] &&\r\n                    dataPriv.get(cur, \"handle\");\r\n                if (handle) {\r\n                    handle.apply(cur, data);\r\n                }\r\n                // Native handler\r\n                handle = ontype && cur[ontype];\r\n                if (handle && handle.apply && acceptData(cur)) {\r\n                    event.result = handle.apply(cur, data);\r\n                    if (event.result === false) {\r\n                        event.preventDefault();\r\n                    }\r\n                }\r\n            }\r\n            event.type = type;\r\n            // If nobody prevented the default action, do it now\r\n            if (!onlyHandlers && !event.isDefaultPrevented()) {\r\n                if ((!special._default ||\r\n                    special._default.apply(eventPath.pop(), data) === false) &&\r\n                    acceptData(elem)) {\r\n                    // Call a native DOM method on the target with the same name as the event.\r\n                    // Don't do default actions on window, that's where global variables be (#6170)\r\n                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {\r\n                        // Don't re-trigger an onFOO event when we call its FOO() method\r\n                        tmp = elem[ontype];\r\n                        if (tmp) {\r\n                            elem[ontype] = null;\r\n                        }\r\n                        // Prevent re-triggering of the same event, since we already bubbled it above\r\n                        jQuery.event.triggered = type;\r\n                        elem[type]();\r\n                        jQuery.event.triggered = undefined;\r\n                        if (tmp) {\r\n                            elem[ontype] = tmp;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return event.result;\r\n        },\r\n        // Piggyback on a donor event to simulate a different one\r\n        // Used only for `focus(in | out)` events\r\n        simulate: function (type, elem, event) {\r\n            var e = jQuery.extend(new jQuery.Event(), event, {\r\n                type: type,\r\n                isSimulated: true\r\n            });\r\n            jQuery.event.trigger(e, null, elem);\r\n        }\r\n    });\r\n    jQuery.fn.extend({\r\n        trigger: function (type, data) {\r\n            return this.each(function () {\r\n                jQuery.event.trigger(type, data, this);\r\n            });\r\n        },\r\n        triggerHandler: function (type, data) {\r\n            var elem = this[0];\r\n            if (elem) {\r\n                return jQuery.event.trigger(type, data, elem, true);\r\n            }\r\n        }\r\n    });\r\n    jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" +\r\n        \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\r\n        \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function (i, name) {\r\n        // Handle event binding\r\n        jQuery.fn[name] = function (data, fn) {\r\n            return arguments.length > 0 ?\r\n                this.on(name, null, data, fn) :\r\n                this.trigger(name);\r\n        };\r\n    });\r\n    jQuery.fn.extend({\r\n        hover: function (fnOver, fnOut) {\r\n            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\r\n        }\r\n    });\r\n    support.focusin = \"onfocusin\" in window;\r\n    // Support: Firefox <=44\r\n    // Firefox doesn't have focus(in | out) events\r\n    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\r\n    //\r\n    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\r\n    // focus(in | out) events fire after focus & blur events,\r\n    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\r\n    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\r\n    if (!support.focusin) {\r\n        jQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function (orig, fix) {\r\n            // Attach a single capturing handler on the document while someone wants focusin/focusout\r\n            var handler = function (event) {\r\n                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\r\n            };\r\n            jQuery.event.special[fix] = {\r\n                setup: function () {\r\n                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);\r\n                    if (!attaches) {\r\n                        doc.addEventListener(orig, handler, true);\r\n                    }\r\n                    dataPriv.access(doc, fix, (attaches || 0) + 1);\r\n                },\r\n                teardown: function () {\r\n                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;\r\n                    if (!attaches) {\r\n                        doc.removeEventListener(orig, handler, true);\r\n                        dataPriv.remove(doc, fix);\r\n                    }\r\n                    else {\r\n                        dataPriv.access(doc, fix, attaches);\r\n                    }\r\n                }\r\n            };\r\n        });\r\n    }\r\n    var location = window.location;\r\n    var nonce = jQuery.now();\r\n    var rquery = (/\\?/);\r\n    // Cross-browser xml parsing\r\n    jQuery.parseXML = function (data) {\r\n        var xml;\r\n        if (!data || typeof data !== \"string\") {\r\n            return null;\r\n        }\r\n        // Support: IE 9 - 11 only\r\n        // IE throws on parseFromString with invalid input.\r\n        try {\r\n            xml = (new window.DOMParser()).parseFromString(data, \"text/xml\");\r\n        }\r\n        catch (e) {\r\n            xml = undefined;\r\n        }\r\n        if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\r\n            jQuery.error(\"Invalid XML: \" + data);\r\n        }\r\n        return xml;\r\n    };\r\n    var rbracket = /\\[\\]$/, rCRLF = /\\r?\\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;\r\n    function buildParams(prefix, obj, traditional, add) {\r\n        var name;\r\n        if (jQuery.isArray(obj)) {\r\n            // Serialize array item.\r\n            jQuery.each(obj, function (i, v) {\r\n                if (traditional || rbracket.test(prefix)) {\r\n                    // Treat each array item as a scalar.\r\n                    add(prefix, v);\r\n                }\r\n                else {\r\n                    // Item is non-scalar (array or object), encode its numeric index.\r\n                    buildParams(prefix + \"[\" + (typeof v === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\r\n                }\r\n            });\r\n        }\r\n        else if (!traditional && jQuery.type(obj) === \"object\") {\r\n            // Serialize object item.\r\n            for (name in obj) {\r\n                buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\r\n            }\r\n        }\r\n        else {\r\n            // Serialize scalar item.\r\n            add(prefix, obj);\r\n        }\r\n    }\r\n    // Serialize an array of form elements or a set of\r\n    // key/values into a query string\r\n    jQuery.param = function (a, traditional) {\r\n        var prefix, s = [], add = function (key, valueOrFunction) {\r\n            // If value is a function, invoke it and use its return value\r\n            var value = jQuery.isFunction(valueOrFunction) ?\r\n                valueOrFunction() :\r\n                valueOrFunction;\r\n            s[s.length] = encodeURIComponent(key) + \"=\" +\r\n                encodeURIComponent(value == null ? \"\" : value);\r\n        };\r\n        // If an array was passed in, assume that it is an array of form elements.\r\n        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {\r\n            // Serialize the form elements\r\n            jQuery.each(a, function () {\r\n                add(this.name, this.value);\r\n            });\r\n        }\r\n        else {\r\n            // If traditional, encode the \"old\" way (the way 1.3.2 or older\r\n            // did it), otherwise encode params recursively.\r\n            for (prefix in a) {\r\n                buildParams(prefix, a[prefix], traditional, add);\r\n            }\r\n        }\r\n        // Return the resulting serialization\r\n        return s.join(\"&\");\r\n    };\r\n    jQuery.fn.extend({\r\n        serialize: function () {\r\n            return jQuery.param(this.serializeArray());\r\n        },\r\n        serializeArray: function () {\r\n            return this.map(function () {\r\n                // Can add propHook for \"elements\" to filter or add form elements\r\n                var elements = jQuery.prop(this, \"elements\");\r\n                return elements ? jQuery.makeArray(elements) : this;\r\n            })\r\n                .filter(function () {\r\n                var type = this.type;\r\n                // Use .is( \":disabled\" ) so that fieldset[disabled] works\r\n                return this.name && !jQuery(this).is(\":disabled\") &&\r\n                    rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&\r\n                    (this.checked || !rcheckableType.test(type));\r\n            })\r\n                .map(function (i, elem) {\r\n                var val = jQuery(this).val();\r\n                if (val == null) {\r\n                    return null;\r\n                }\r\n                if (jQuery.isArray(val)) {\r\n                    return jQuery.map(val, function (val) {\r\n                        return { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\r\n                    });\r\n                }\r\n                return { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\r\n            }).get();\r\n        }\r\n    });\r\n    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg, \r\n    // #7653, #8125, #8152: local protocol detection\r\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\\/\\//, \r\n    /* Prefilters\r\n     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\r\n     * 2) These are called:\r\n     *    - BEFORE asking for a transport\r\n     *    - AFTER param serialization (s.data is a string if s.processData is true)\r\n     * 3) key is the dataType\r\n     * 4) the catchall symbol \"*\" can be used\r\n     * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\r\n     */\r\n    prefilters = {}, \r\n    /* Transports bindings\r\n     * 1) key is the dataType\r\n     * 2) the catchall symbol \"*\" can be used\r\n     * 3) selection will start with transport dataType and THEN go to \"*\" if needed\r\n     */\r\n    transports = {}, \r\n    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\r\n    allTypes = \"*/\".concat(\"*\"), \r\n    // Anchor tag for parsing the document origin\r\n    originAnchor = document.createElement(\"a\");\r\n    originAnchor.href = location.href;\r\n    // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\r\n    function addToPrefiltersOrTransports(structure) {\r\n        // dataTypeExpression is optional and defaults to \"*\"\r\n        return function (dataTypeExpression, func) {\r\n            if (typeof dataTypeExpression !== \"string\") {\r\n                func = dataTypeExpression;\r\n                dataTypeExpression = \"*\";\r\n            }\r\n            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\r\n            if (jQuery.isFunction(func)) {\r\n                // For each dataType in the dataTypeExpression\r\n                while ((dataType = dataTypes[i++])) {\r\n                    // Prepend if requested\r\n                    if (dataType[0] === \"+\") {\r\n                        dataType = dataType.slice(1) || \"*\";\r\n                        (structure[dataType] = structure[dataType] || []).unshift(func);\r\n                    }\r\n                    else {\r\n                        (structure[dataType] = structure[dataType] || []).push(func);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n    // Base inspection function for prefilters and transports\r\n    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\r\n        var inspected = {}, seekingTransport = (structure === transports);\r\n        function inspect(dataType) {\r\n            var selected;\r\n            inspected[dataType] = true;\r\n            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\r\n                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\r\n                if (typeof dataTypeOrTransport === \"string\" &&\r\n                    !seekingTransport && !inspected[dataTypeOrTransport]) {\r\n                    options.dataTypes.unshift(dataTypeOrTransport);\r\n                    inspect(dataTypeOrTransport);\r\n                    return false;\r\n                }\r\n                else if (seekingTransport) {\r\n                    return !(selected = dataTypeOrTransport);\r\n                }\r\n            });\r\n            return selected;\r\n        }\r\n        return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\r\n    }\r\n    // A special extend for ajax options\r\n    // that takes \"flat\" options (not to be deep extended)\r\n    // Fixes #9887\r\n    function ajaxExtend(target, src) {\r\n        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};\r\n        for (key in src) {\r\n            if (src[key] !== undefined) {\r\n                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];\r\n            }\r\n        }\r\n        if (deep) {\r\n            jQuery.extend(true, target, deep);\r\n        }\r\n        return target;\r\n    }\r\n    /* Handles responses to an ajax request:\r\n     * - finds the right dataType (mediates between content-type and expected dataType)\r\n     * - returns the corresponding response\r\n     */\r\n    function ajaxHandleResponses(s, jqXHR, responses) {\r\n        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;\r\n        // Remove auto dataType and get content-type in the process\r\n        while (dataTypes[0] === \"*\") {\r\n            dataTypes.shift();\r\n            if (ct === undefined) {\r\n                ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\r\n            }\r\n        }\r\n        // Check if we're dealing with a known content-type\r\n        if (ct) {\r\n            for (type in contents) {\r\n                if (contents[type] && contents[type].test(ct)) {\r\n                    dataTypes.unshift(type);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // Check to see if we have a response for the expected dataType\r\n        if (dataTypes[0] in responses) {\r\n            finalDataType = dataTypes[0];\r\n        }\r\n        else {\r\n            // Try convertible dataTypes\r\n            for (type in responses) {\r\n                if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\r\n                    finalDataType = type;\r\n                    break;\r\n                }\r\n                if (!firstDataType) {\r\n                    firstDataType = type;\r\n                }\r\n            }\r\n            // Or just use first one\r\n            finalDataType = finalDataType || firstDataType;\r\n        }\r\n        // If we found a dataType\r\n        // We add the dataType to the list if needed\r\n        // and return the corresponding response\r\n        if (finalDataType) {\r\n            if (finalDataType !== dataTypes[0]) {\r\n                dataTypes.unshift(finalDataType);\r\n            }\r\n            return responses[finalDataType];\r\n        }\r\n    }\r\n    /* Chain conversions given the request and the original response\r\n     * Also sets the responseXXX fields on the jqXHR instance\r\n     */\r\n    function ajaxConvert(s, response, jqXHR, isSuccess) {\r\n        var conv2, current, conv, tmp, prev, converters = {}, \r\n        // Work with a copy of dataTypes in case we need to modify it for conversion\r\n        dataTypes = s.dataTypes.slice();\r\n        // Create converters map with lowercased keys\r\n        if (dataTypes[1]) {\r\n            for (conv in s.converters) {\r\n                converters[conv.toLowerCase()] = s.converters[conv];\r\n            }\r\n        }\r\n        current = dataTypes.shift();\r\n        // Convert to each sequential dataType\r\n        while (current) {\r\n            if (s.responseFields[current]) {\r\n                jqXHR[s.responseFields[current]] = response;\r\n            }\r\n            // Apply the dataFilter if provided\r\n            if (!prev && isSuccess && s.dataFilter) {\r\n                response = s.dataFilter(response, s.dataType);\r\n            }\r\n            prev = current;\r\n            current = dataTypes.shift();\r\n            if (current) {\r\n                // There's only work to do if current dataType is non-auto\r\n                if (current === \"*\") {\r\n                    current = prev;\r\n                }\r\n                else if (prev !== \"*\" && prev !== current) {\r\n                    // Seek a direct converter\r\n                    conv = converters[prev + \" \" + current] || converters[\"* \" + current];\r\n                    // If none found, seek a pair\r\n                    if (!conv) {\r\n                        for (conv2 in converters) {\r\n                            // If conv2 outputs current\r\n                            tmp = conv2.split(\" \");\r\n                            if (tmp[1] === current) {\r\n                                // If prev can be converted to accepted input\r\n                                conv = converters[prev + \" \" + tmp[0]] ||\r\n                                    converters[\"* \" + tmp[0]];\r\n                                if (conv) {\r\n                                    // Condense equivalence converters\r\n                                    if (conv === true) {\r\n                                        conv = converters[conv2];\r\n                                    }\r\n                                    else if (converters[conv2] !== true) {\r\n                                        current = tmp[0];\r\n                                        dataTypes.unshift(tmp[1]);\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    // Apply converter (if not an equivalence)\r\n                    if (conv !== true) {\r\n                        // Unless errors are allowed to bubble, catch and return them\r\n                        if (conv && s.throws) {\r\n                            response = conv(response);\r\n                        }\r\n                        else {\r\n                            try {\r\n                                response = conv(response);\r\n                            }\r\n                            catch (e) {\r\n                                return {\r\n                                    state: \"parsererror\",\r\n                                    error: conv ? e : \"No conversion from \" + prev + \" to \" + current\r\n                                };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return { state: \"success\", data: response };\r\n    }\r\n    jQuery.extend({\r\n        // Counter for holding the number of active queries\r\n        active: 0,\r\n        // Last-Modified header cache for next request\r\n        lastModified: {},\r\n        etag: {},\r\n        ajaxSettings: {\r\n            url: location.href,\r\n            type: \"GET\",\r\n            isLocal: rlocalProtocol.test(location.protocol),\r\n            global: true,\r\n            processData: true,\r\n            async: true,\r\n            contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n            /*\r\n            timeout: 0,\r\n            data: null,\r\n            dataType: null,\r\n            username: null,\r\n            password: null,\r\n            cache: null,\r\n            throws: false,\r\n            traditional: false,\r\n            headers: {},\r\n            */\r\n            accepts: {\r\n                \"*\": allTypes,\r\n                text: \"text/plain\",\r\n                html: \"text/html\",\r\n                xml: \"application/xml, text/xml\",\r\n                json: \"application/json, text/javascript\"\r\n            },\r\n            contents: {\r\n                xml: /\\bxml\\b/,\r\n                html: /\\bhtml/,\r\n                json: /\\bjson\\b/\r\n            },\r\n            responseFields: {\r\n                xml: \"responseXML\",\r\n                text: \"responseText\",\r\n                json: \"responseJSON\"\r\n            },\r\n            // Data converters\r\n            // Keys separate source (or catchall \"*\") and destination types with a single space\r\n            converters: {\r\n                // Convert anything to text\r\n                \"* text\": String,\r\n                // Text to html (true = no transformation)\r\n                \"text html\": true,\r\n                // Evaluate text as a json expression\r\n                \"text json\": JSON.parse,\r\n                // Parse text as xml\r\n                \"text xml\": jQuery.parseXML\r\n            },\r\n            // For options that shouldn't be deep extended:\r\n            // you can add your own custom options here if\r\n            // and when you create one that shouldn't be\r\n            // deep extended (see ajaxExtend)\r\n            flatOptions: {\r\n                url: true,\r\n                context: true\r\n            }\r\n        },\r\n        // Creates a full fledged settings object into target\r\n        // with both ajaxSettings and settings fields.\r\n        // If target is omitted, writes into ajaxSettings.\r\n        ajaxSetup: function (target, settings) {\r\n            return settings ?\r\n                // Building a settings object\r\n                ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :\r\n                // Extending ajaxSettings\r\n                ajaxExtend(jQuery.ajaxSettings, target);\r\n        },\r\n        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\r\n        ajaxTransport: addToPrefiltersOrTransports(transports),\r\n        // Main method\r\n        ajax: function (url, options) {\r\n            // If url is an object, simulate pre-1.5 signature\r\n            if (typeof url === \"object\") {\r\n                options = url;\r\n                url = undefined;\r\n            }\r\n            // Force options to be an object\r\n            options = options || {};\r\n            var transport, \r\n            // URL without anti-cache param\r\n            cacheURL, \r\n            // Response headers\r\n            responseHeadersString, responseHeaders, \r\n            // timeout handle\r\n            timeoutTimer, \r\n            // Url cleanup var\r\n            urlAnchor, \r\n            // Request state (becomes false upon send and true upon completion)\r\n            completed, \r\n            // To know if global events are to be dispatched\r\n            fireGlobals, \r\n            // Loop variable\r\n            i, \r\n            // uncached part of the url\r\n            uncached, \r\n            // Create the final options object\r\n            s = jQuery.ajaxSetup({}, options), \r\n            // Callbacks context\r\n            callbackContext = s.context || s, \r\n            // Context for global events is callbackContext if it is a DOM node or jQuery collection\r\n            globalEventContext = s.context &&\r\n                (callbackContext.nodeType || callbackContext.jquery) ?\r\n                jQuery(callbackContext) :\r\n                jQuery.event, \r\n            // Deferreds\r\n            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks(\"once memory\"), \r\n            // Status-dependent callbacks\r\n            statusCode = s.statusCode || {}, \r\n            // Headers (they are sent all at once)\r\n            requestHeaders = {}, requestHeadersNames = {}, \r\n            // Default abort message\r\n            strAbort = \"canceled\", \r\n            // Fake xhr\r\n            jqXHR = {\r\n                readyState: 0,\r\n                // Builds headers hashtable if needed\r\n                getResponseHeader: function (key) {\r\n                    var match;\r\n                    if (completed) {\r\n                        if (!responseHeaders) {\r\n                            responseHeaders = {};\r\n                            while ((match = rheaders.exec(responseHeadersString))) {\r\n                                responseHeaders[match[1].toLowerCase()] = match[2];\r\n                            }\r\n                        }\r\n                        match = responseHeaders[key.toLowerCase()];\r\n                    }\r\n                    return match == null ? null : match;\r\n                },\r\n                // Raw string\r\n                getAllResponseHeaders: function () {\r\n                    return completed ? responseHeadersString : null;\r\n                },\r\n                // Caches the header\r\n                setRequestHeader: function (name, value) {\r\n                    if (completed == null) {\r\n                        name = requestHeadersNames[name.toLowerCase()] =\r\n                            requestHeadersNames[name.toLowerCase()] || name;\r\n                        requestHeaders[name] = value;\r\n                    }\r\n                    return this;\r\n                },\r\n                // Overrides response content-type header\r\n                overrideMimeType: function (type) {\r\n                    if (completed == null) {\r\n                        s.mimeType = type;\r\n                    }\r\n                    return this;\r\n                },\r\n                // Status-dependent callbacks\r\n                statusCode: function (map) {\r\n                    var code;\r\n                    if (map) {\r\n                        if (completed) {\r\n                            // Execute the appropriate callbacks\r\n                            jqXHR.always(map[jqXHR.status]);\r\n                        }\r\n                        else {\r\n                            // Lazy-add the new callbacks in a way that preserves old ones\r\n                            for (code in map) {\r\n                                statusCode[code] = [statusCode[code], map[code]];\r\n                            }\r\n                        }\r\n                    }\r\n                    return this;\r\n                },\r\n                // Cancel the request\r\n                abort: function (statusText) {\r\n                    var finalText = statusText || strAbort;\r\n                    if (transport) {\r\n                        transport.abort(finalText);\r\n                    }\r\n                    done(0, finalText);\r\n                    return this;\r\n                }\r\n            };\r\n            // Attach deferreds\r\n            deferred.promise(jqXHR);\r\n            // Add protocol if not provided (prefilters might expect it)\r\n            // Handle falsy url in the settings object (#10093: consistency with old signature)\r\n            // We also use the url parameter if available\r\n            s.url = ((url || s.url || location.href) + \"\")\r\n                .replace(rprotocol, location.protocol + \"//\");\r\n            // Alias method option to type as per ticket #12004\r\n            s.type = options.method || options.type || s.method || s.type;\r\n            // Extract dataTypes list\r\n            s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"];\r\n            // A cross-domain request is in order when the origin doesn't match the current origin.\r\n            if (s.crossDomain == null) {\r\n                urlAnchor = document.createElement(\"a\");\r\n                // Support: IE <=8 - 11, Edge 12 - 13\r\n                // IE throws exception on accessing the href property if url is malformed,\r\n                // e.g. http://example.com:80x/\r\n                try {\r\n                    urlAnchor.href = s.url;\r\n                    // Support: IE <=8 - 11 only\r\n                    // Anchor's host property isn't correctly set when s.url is relative\r\n                    urlAnchor.href = urlAnchor.href;\r\n                    s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\r\n                        urlAnchor.protocol + \"//\" + urlAnchor.host;\r\n                }\r\n                catch (e) {\r\n                    // If there is an error parsing the URL, assume it is crossDomain,\r\n                    // it can be rejected by the transport if it is invalid\r\n                    s.crossDomain = true;\r\n                }\r\n            }\r\n            // Convert data if not already a string\r\n            if (s.data && s.processData && typeof s.data !== \"string\") {\r\n                s.data = jQuery.param(s.data, s.traditional);\r\n            }\r\n            // Apply prefilters\r\n            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\r\n            // If request was aborted inside a prefilter, stop there\r\n            if (completed) {\r\n                return jqXHR;\r\n            }\r\n            // We can fire global events as of now if asked to\r\n            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\r\n            fireGlobals = jQuery.event && s.global;\r\n            // Watch for a new set of requests\r\n            if (fireGlobals && jQuery.active++ === 0) {\r\n                jQuery.event.trigger(\"ajaxStart\");\r\n            }\r\n            // Uppercase the type\r\n            s.type = s.type.toUpperCase();\r\n            // Determine if request has content\r\n            s.hasContent = !rnoContent.test(s.type);\r\n            // Save the URL in case we're toying with the If-Modified-Since\r\n            // and/or If-None-Match header later on\r\n            // Remove hash to simplify url manipulation\r\n            cacheURL = s.url.replace(rhash, \"\");\r\n            // More options handling for requests with no content\r\n            if (!s.hasContent) {\r\n                // Remember the hash so we can put it back\r\n                uncached = s.url.slice(cacheURL.length);\r\n                // If data is available, append data to url\r\n                if (s.data) {\r\n                    cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\r\n                    // #9682: remove data so that it's not used in an eventual retry\r\n                    delete s.data;\r\n                }\r\n                // Add or update anti-cache param if needed\r\n                if (s.cache === false) {\r\n                    cacheURL = cacheURL.replace(rantiCache, \"$1\");\r\n                    uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + (nonce++) + uncached;\r\n                }\r\n                // Put hash and anti-cache on the URL that will be requested (gh-1732)\r\n                s.url = cacheURL + uncached;\r\n            }\r\n            else if (s.data && s.processData &&\r\n                (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\r\n                s.data = s.data.replace(r20, \"+\");\r\n            }\r\n            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n            if (s.ifModified) {\r\n                if (jQuery.lastModified[cacheURL]) {\r\n                    jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\r\n                }\r\n                if (jQuery.etag[cacheURL]) {\r\n                    jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\r\n                }\r\n            }\r\n            // Set the correct header, if data is being sent\r\n            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\r\n                jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\r\n            }\r\n            // Set the Accepts header for the server, depending on the dataType\r\n            jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?\r\n                s.accepts[s.dataTypes[0]] +\r\n                    (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") :\r\n                s.accepts[\"*\"]);\r\n            // Check for headers option\r\n            for (i in s.headers) {\r\n                jqXHR.setRequestHeader(i, s.headers[i]);\r\n            }\r\n            // Allow custom headers/mimetypes and early abort\r\n            if (s.beforeSend &&\r\n                (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\r\n                // Abort if not done already and return\r\n                return jqXHR.abort();\r\n            }\r\n            // Aborting is no longer a cancellation\r\n            strAbort = \"abort\";\r\n            // Install callbacks on deferreds\r\n            completeDeferred.add(s.complete);\r\n            jqXHR.done(s.success);\r\n            jqXHR.fail(s.error);\r\n            // Get transport\r\n            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\r\n            // If no transport, we auto-abort\r\n            if (!transport) {\r\n                done(-1, \"No Transport\");\r\n            }\r\n            else {\r\n                jqXHR.readyState = 1;\r\n                // Send global event\r\n                if (fireGlobals) {\r\n                    globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\r\n                }\r\n                // If request was aborted inside ajaxSend, stop there\r\n                if (completed) {\r\n                    return jqXHR;\r\n                }\r\n                // Timeout\r\n                if (s.async && s.timeout > 0) {\r\n                    timeoutTimer = window.setTimeout(function () {\r\n                        jqXHR.abort(\"timeout\");\r\n                    }, s.timeout);\r\n                }\r\n                try {\r\n                    completed = false;\r\n                    transport.send(requestHeaders, done);\r\n                }\r\n                catch (e) {\r\n                    // Rethrow post-completion exceptions\r\n                    if (completed) {\r\n                        throw e;\r\n                    }\r\n                    // Propagate others as results\r\n                    done(-1, e);\r\n                }\r\n            }\r\n            // Callback for when everything is done\r\n            function done(status, nativeStatusText, responses, headers) {\r\n                var isSuccess, success, error, response, modified, statusText = nativeStatusText;\r\n                // Ignore repeat invocations\r\n                if (completed) {\r\n                    return;\r\n                }\r\n                completed = true;\r\n                // Clear timeout if it exists\r\n                if (timeoutTimer) {\r\n                    window.clearTimeout(timeoutTimer);\r\n                }\r\n                // Dereference transport for early garbage collection\r\n                // (no matter how long the jqXHR object will be used)\r\n                transport = undefined;\r\n                // Cache response headers\r\n                responseHeadersString = headers || \"\";\r\n                // Set readyState\r\n                jqXHR.readyState = status > 0 ? 4 : 0;\r\n                // Determine if successful\r\n                isSuccess = status >= 200 && status < 300 || status === 304;\r\n                // Get response data\r\n                if (responses) {\r\n                    response = ajaxHandleResponses(s, jqXHR, responses);\r\n                }\r\n                // Convert no matter what (that way responseXXX fields are always set)\r\n                response = ajaxConvert(s, response, jqXHR, isSuccess);\r\n                // If successful, handle type chaining\r\n                if (isSuccess) {\r\n                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n                    if (s.ifModified) {\r\n                        modified = jqXHR.getResponseHeader(\"Last-Modified\");\r\n                        if (modified) {\r\n                            jQuery.lastModified[cacheURL] = modified;\r\n                        }\r\n                        modified = jqXHR.getResponseHeader(\"etag\");\r\n                        if (modified) {\r\n                            jQuery.etag[cacheURL] = modified;\r\n                        }\r\n                    }\r\n                    // if no content\r\n                    if (status === 204 || s.type === \"HEAD\") {\r\n                        statusText = \"nocontent\";\r\n                    }\r\n                    else if (status === 304) {\r\n                        statusText = \"notmodified\";\r\n                    }\r\n                    else {\r\n                        statusText = response.state;\r\n                        success = response.data;\r\n                        error = response.error;\r\n                        isSuccess = !error;\r\n                    }\r\n                }\r\n                else {\r\n                    // Extract error from statusText and normalize for non-aborts\r\n                    error = statusText;\r\n                    if (status || !statusText) {\r\n                        statusText = \"error\";\r\n                        if (status < 0) {\r\n                            status = 0;\r\n                        }\r\n                    }\r\n                }\r\n                // Set data for the fake xhr object\r\n                jqXHR.status = status;\r\n                jqXHR.statusText = (nativeStatusText || statusText) + \"\";\r\n                // Success/Error\r\n                if (isSuccess) {\r\n                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\r\n                }\r\n                else {\r\n                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\r\n                }\r\n                // Status-dependent callbacks\r\n                jqXHR.statusCode(statusCode);\r\n                statusCode = undefined;\r\n                if (fireGlobals) {\r\n                    globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\r\n                }\r\n                // Complete\r\n                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\r\n                if (fireGlobals) {\r\n                    globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]);\r\n                    // Handle the global AJAX counter\r\n                    if (!(--jQuery.active)) {\r\n                        jQuery.event.trigger(\"ajaxStop\");\r\n                    }\r\n                }\r\n            }\r\n            return jqXHR;\r\n        },\r\n        getJSON: function (url, data, callback) {\r\n            return jQuery.get(url, data, callback, \"json\");\r\n        },\r\n        getScript: function (url, callback) {\r\n            return jQuery.get(url, undefined, callback, \"script\");\r\n        }\r\n    });\r\n    jQuery.each([\"get\", \"post\"], function (i, method) {\r\n        jQuery[method] = function (url, data, callback, type) {\r\n            // Shift arguments if data argument was omitted\r\n            if (jQuery.isFunction(data)) {\r\n                type = type || callback;\r\n                callback = data;\r\n                data = undefined;\r\n            }\r\n            // The url can be an options object (which then must have .url)\r\n            return jQuery.ajax(jQuery.extend({\r\n                url: url,\r\n                type: method,\r\n                dataType: type,\r\n                data: data,\r\n                success: callback\r\n            }, jQuery.isPlainObject(url) && url));\r\n        };\r\n    });\r\n    jQuery._evalUrl = function (url) {\r\n        return jQuery.ajax({\r\n            url: url,\r\n            // Make this explicit, since user can override this through ajaxSetup (#11264)\r\n            type: \"GET\",\r\n            dataType: \"script\",\r\n            cache: true,\r\n            async: false,\r\n            global: false,\r\n            \"throws\": true\r\n        });\r\n    };\r\n    jQuery.fn.extend({\r\n        wrapAll: function (html) {\r\n            var wrap;\r\n            if (this[0]) {\r\n                if (jQuery.isFunction(html)) {\r\n                    html = html.call(this[0]);\r\n                }\r\n                // The elements to wrap the target around\r\n                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\r\n                if (this[0].parentNode) {\r\n                    wrap.insertBefore(this[0]);\r\n                }\r\n                wrap.map(function () {\r\n                    var elem = this;\r\n                    while (elem.firstElementChild) {\r\n                        elem = elem.firstElementChild;\r\n                    }\r\n                    return elem;\r\n                }).append(this);\r\n            }\r\n            return this;\r\n        },\r\n        wrapInner: function (html) {\r\n            if (jQuery.isFunction(html)) {\r\n                return this.each(function (i) {\r\n                    jQuery(this).wrapInner(html.call(this, i));\r\n                });\r\n            }\r\n            return this.each(function () {\r\n                var self = jQuery(this), contents = self.contents();\r\n                if (contents.length) {\r\n                    contents.wrapAll(html);\r\n                }\r\n                else {\r\n                    self.append(html);\r\n                }\r\n            });\r\n        },\r\n        wrap: function (html) {\r\n            var isFunction = jQuery.isFunction(html);\r\n            return this.each(function (i) {\r\n                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\r\n            });\r\n        },\r\n        unwrap: function (selector) {\r\n            this.parent(selector).not(\"body\").each(function () {\r\n                jQuery(this).replaceWith(this.childNodes);\r\n            });\r\n            return this;\r\n        }\r\n    });\r\n    jQuery.expr.pseudos.hidden = function (elem) {\r\n        return !jQuery.expr.pseudos.visible(elem);\r\n    };\r\n    jQuery.expr.pseudos.visible = function (elem) {\r\n        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\r\n    };\r\n    jQuery.ajaxSettings.xhr = function () {\r\n        try {\r\n            return new window.XMLHttpRequest();\r\n        }\r\n        catch (e) { }\r\n    };\r\n    var xhrSuccessStatus = {\r\n        // File protocol always yields status code 0, assume 200\r\n        0: 200,\r\n        // Support: IE <=9 only\r\n        // #1450: sometimes IE returns 1223 when it should be 204\r\n        1223: 204\r\n    }, xhrSupported = jQuery.ajaxSettings.xhr();\r\n    support.cors = !!xhrSupported && (\"withCredentials\" in xhrSupported);\r\n    support.ajax = xhrSupported = !!xhrSupported;\r\n    jQuery.ajaxTransport(function (options) {\r\n        var callback, errorCallback;\r\n        // Cross domain only allowed if supported through XMLHttpRequest\r\n        if (support.cors || xhrSupported && !options.crossDomain) {\r\n            return {\r\n                send: function (headers, complete) {\r\n                    var i, xhr = options.xhr();\r\n                    xhr.open(options.type, options.url, options.async, options.username, options.password);\r\n                    // Apply custom fields if provided\r\n                    if (options.xhrFields) {\r\n                        for (i in options.xhrFields) {\r\n                            xhr[i] = options.xhrFields[i];\r\n                        }\r\n                    }\r\n                    // Override mime type if needed\r\n                    if (options.mimeType && xhr.overrideMimeType) {\r\n                        xhr.overrideMimeType(options.mimeType);\r\n                    }\r\n                    // X-Requested-With header\r\n                    // For cross-domain requests, seeing as conditions for a preflight are\r\n                    // akin to a jigsaw puzzle, we simply never set it to be sure.\r\n                    // (it can always be set on a per-request basis or even using ajaxSetup)\r\n                    // For same-domain requests, won't change header if already provided.\r\n                    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\r\n                        headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\r\n                    }\r\n                    // Set headers\r\n                    for (i in headers) {\r\n                        xhr.setRequestHeader(i, headers[i]);\r\n                    }\r\n                    // Callback\r\n                    callback = function (type) {\r\n                        return function () {\r\n                            if (callback) {\r\n                                callback = errorCallback = xhr.onload =\r\n                                    xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\r\n                                if (type === \"abort\") {\r\n                                    xhr.abort();\r\n                                }\r\n                                else if (type === \"error\") {\r\n                                    // Support: IE <=9 only\r\n                                    // On a manual native abort, IE9 throws\r\n                                    // errors on any property access that is not readyState\r\n                                    if (typeof xhr.status !== \"number\") {\r\n                                        complete(0, \"error\");\r\n                                    }\r\n                                    else {\r\n                                        complete(\r\n                                        // File: protocol always yields status 0; see #8605, #14207\r\n                                        xhr.status, xhr.statusText);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, \r\n                                    // Support: IE <=9 only\r\n                                    // IE9 has no XHR2 but throws on binary (trac-11426)\r\n                                    // For XHR2 non-text, let the caller handle it (gh-2498)\r\n                                    (xhr.responseType || \"text\") !== \"text\" ||\r\n                                        typeof xhr.responseText !== \"string\" ?\r\n                                        { binary: xhr.response } :\r\n                                        { text: xhr.responseText }, xhr.getAllResponseHeaders());\r\n                                }\r\n                            }\r\n                        };\r\n                    };\r\n                    // Listen to events\r\n                    xhr.onload = callback();\r\n                    errorCallback = xhr.onerror = callback(\"error\");\r\n                    // Support: IE 9 only\r\n                    // Use onreadystatechange to replace onabort\r\n                    // to handle uncaught aborts\r\n                    if (xhr.onabort !== undefined) {\r\n                        xhr.onabort = errorCallback;\r\n                    }\r\n                    else {\r\n                        xhr.onreadystatechange = function () {\r\n                            // Check readyState before timeout as it changes\r\n                            if (xhr.readyState === 4) {\r\n                                // Allow onerror to be called first,\r\n                                // but that will not handle a native abort\r\n                                // Also, save errorCallback to a variable\r\n                                // as xhr.onerror cannot be accessed\r\n                                window.setTimeout(function () {\r\n                                    if (callback) {\r\n                                        errorCallback();\r\n                                    }\r\n                                });\r\n                            }\r\n                        };\r\n                    }\r\n                    // Create the abort callback\r\n                    callback = callback(\"abort\");\r\n                    try {\r\n                        // Do send the request (this may raise an exception)\r\n                        xhr.send(options.hasContent && options.data || null);\r\n                    }\r\n                    catch (e) {\r\n                        // #14683: Only rethrow if this hasn't been notified as an error yet\r\n                        if (callback) {\r\n                            throw e;\r\n                        }\r\n                    }\r\n                },\r\n                abort: function () {\r\n                    if (callback) {\r\n                        callback();\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    });\r\n    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\r\n    jQuery.ajaxPrefilter(function (s) {\r\n        if (s.crossDomain) {\r\n            s.contents.script = false;\r\n        }\r\n    });\r\n    // Install script dataType\r\n    jQuery.ajaxSetup({\r\n        accepts: {\r\n            script: \"text/javascript, application/javascript, \" +\r\n                \"application/ecmascript, application/x-ecmascript\"\r\n        },\r\n        contents: {\r\n            script: /\\b(?:java|ecma)script\\b/\r\n        },\r\n        converters: {\r\n            \"text script\": function (text) {\r\n                jQuery.globalEval(text);\r\n                return text;\r\n            }\r\n        }\r\n    });\r\n    // Handle cache's special case and crossDomain\r\n    jQuery.ajaxPrefilter(\"script\", function (s) {\r\n        if (s.cache === undefined) {\r\n            s.cache = false;\r\n        }\r\n        if (s.crossDomain) {\r\n            s.type = \"GET\";\r\n        }\r\n    });\r\n    // Bind script tag hack transport\r\n    jQuery.ajaxTransport(\"script\", function (s) {\r\n        // This transport only deals with cross domain requests\r\n        if (s.crossDomain) {\r\n            var script, callback;\r\n            return {\r\n                send: function (_, complete) {\r\n                    script = jQuery(\"<script>\").prop({\r\n                        charset: s.scriptCharset,\r\n                        src: s.url\r\n                    }).on(\"load error\", callback = function (evt) {\r\n                        script.remove();\r\n                        callback = null;\r\n                        if (evt) {\r\n                            complete(evt.type === \"error\" ? 404 : 200, evt.type);\r\n                        }\r\n                    });\r\n                    // Use native DOM manipulation to avoid our domManip AJAX trickery\r\n                    document.head.appendChild(script[0]);\r\n                },\r\n                abort: function () {\r\n                    if (callback) {\r\n                        callback();\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    });\r\n    var oldCallbacks = [], rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\r\n    // Default jsonp settings\r\n    jQuery.ajaxSetup({\r\n        jsonp: \"callback\",\r\n        jsonpCallback: function () {\r\n            var callback = oldCallbacks.pop() || (jQuery.expando + \"_\" + (nonce++));\r\n            this[callback] = true;\r\n            return callback;\r\n        }\r\n    });\r\n    // Detect, normalize options and install callbacks for jsonp requests\r\n    jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\r\n        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?\r\n            \"url\" :\r\n            typeof s.data === \"string\" &&\r\n                (s.contentType || \"\")\r\n                    .indexOf(\"application/x-www-form-urlencoded\") === 0 &&\r\n                rjsonp.test(s.data) && \"data\");\r\n        // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\r\n        if (jsonProp || s.dataTypes[0] === \"jsonp\") {\r\n            // Get callback name, remembering preexisting value associated with it\r\n            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?\r\n                s.jsonpCallback() :\r\n                s.jsonpCallback;\r\n            // Insert callback into url or form data\r\n            if (jsonProp) {\r\n                s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\r\n            }\r\n            else if (s.jsonp !== false) {\r\n                s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\r\n            }\r\n            // Use data converter to retrieve json after script execution\r\n            s.converters[\"script json\"] = function () {\r\n                if (!responseContainer) {\r\n                    jQuery.error(callbackName + \" was not called\");\r\n                }\r\n                return responseContainer[0];\r\n            };\r\n            // Force json dataType\r\n            s.dataTypes[0] = \"json\";\r\n            // Install callback\r\n            overwritten = window[callbackName];\r\n            window[callbackName] = function () {\r\n                responseContainer = arguments;\r\n            };\r\n            // Clean-up function (fires after converters)\r\n            jqXHR.always(function () {\r\n                // If previous value didn't exist - remove it\r\n                if (overwritten === undefined) {\r\n                    jQuery(window).removeProp(callbackName);\r\n                }\r\n                else {\r\n                    window[callbackName] = overwritten;\r\n                }\r\n                // Save back as free\r\n                if (s[callbackName]) {\r\n                    // Make sure that re-using the options doesn't screw things around\r\n                    s.jsonpCallback = originalSettings.jsonpCallback;\r\n                    // Save the callback name for future use\r\n                    oldCallbacks.push(callbackName);\r\n                }\r\n                // Call if it was a function and we have a response\r\n                if (responseContainer && jQuery.isFunction(overwritten)) {\r\n                    overwritten(responseContainer[0]);\r\n                }\r\n                responseContainer = overwritten = undefined;\r\n            });\r\n            // Delegate to script\r\n            return \"script\";\r\n        }\r\n    });\r\n    // Support: Safari 8 only\r\n    // In Safari 8 documents created via document.implementation.createHTMLDocument\r\n    // collapse sibling forms: the second one becomes a child of the first one.\r\n    // Because of that, this security measure has to be disabled in Safari 8.\r\n    // https://bugs.webkit.org/show_bug.cgi?id=137337\r\n    support.createHTMLDocument = (function () {\r\n        var body = document.implementation.createHTMLDocument(\"\").body;\r\n        body.innerHTML = \"<form></form><form></form>\";\r\n        return body.childNodes.length === 2;\r\n    })();\r\n    // Argument \"data\" should be string of html\r\n    // context (optional): If specified, the fragment will be created in this context,\r\n    // defaults to document\r\n    // keepScripts (optional): If true, will include scripts passed in the html string\r\n    jQuery.parseHTML = function (data, context, keepScripts) {\r\n        if (typeof data !== \"string\") {\r\n            return [];\r\n        }\r\n        if (typeof context === \"boolean\") {\r\n            keepScripts = context;\r\n            context = false;\r\n        }\r\n        var base, parsed, scripts;\r\n        if (!context) {\r\n            // Stop scripts or inline event handlers from being executed immediately\r\n            // by using document.implementation\r\n            if (support.createHTMLDocument) {\r\n                context = document.implementation.createHTMLDocument(\"\");\r\n                // Set the base href for the created document\r\n                // so any parsed elements with URLs\r\n                // are based on the document's URL (gh-2965)\r\n                base = context.createElement(\"base\");\r\n                base.href = document.location.href;\r\n                context.head.appendChild(base);\r\n            }\r\n            else {\r\n                context = document;\r\n            }\r\n        }\r\n        parsed = rsingleTag.exec(data);\r\n        scripts = !keepScripts && [];\r\n        // Single tag\r\n        if (parsed) {\r\n            return [context.createElement(parsed[1])];\r\n        }\r\n        parsed = buildFragment([data], context, scripts);\r\n        if (scripts && scripts.length) {\r\n            jQuery(scripts).remove();\r\n        }\r\n        return jQuery.merge([], parsed.childNodes);\r\n    };\r\n    /**\r\n     * Load a url into a page\r\n     */\r\n    jQuery.fn.load = function (url, params, callback) {\r\n        var selector, type, response, self = this, off = url.indexOf(\" \");\r\n        if (off > -1) {\r\n            selector = stripAndCollapse(url.slice(off));\r\n            url = url.slice(0, off);\r\n        }\r\n        // If it's a function\r\n        if (jQuery.isFunction(params)) {\r\n            // We assume that it's the callback\r\n            callback = params;\r\n            params = undefined;\r\n        }\r\n        else if (params && typeof params === \"object\") {\r\n            type = \"POST\";\r\n        }\r\n        // If we have elements to modify, make the request\r\n        if (self.length > 0) {\r\n            jQuery.ajax({\r\n                url: url,\r\n                // If \"type\" variable is undefined, then \"GET\" method will be used.\r\n                // Make value of this field explicit since\r\n                // user can override it through ajaxSetup method\r\n                type: type || \"GET\",\r\n                dataType: \"html\",\r\n                data: params\r\n            }).done(function (responseText) {\r\n                // Save response for use in complete callback\r\n                response = arguments;\r\n                self.html(selector ?\r\n                    // If a selector was specified, locate the right elements in a dummy div\r\n                    // Exclude scripts to avoid IE 'Permission Denied' errors\r\n                    jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) :\r\n                    // Otherwise use the full result\r\n                    responseText);\r\n                // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\r\n                // but they are ignored because response was set above.\r\n                // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\r\n            }).always(callback && function (jqXHR, status) {\r\n                self.each(function () {\r\n                    callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\r\n                });\r\n            });\r\n        }\r\n        return this;\r\n    };\r\n    // Attach a bunch of functions for handling common AJAX events\r\n    jQuery.each([\r\n        \"ajaxStart\",\r\n        \"ajaxStop\",\r\n        \"ajaxComplete\",\r\n        \"ajaxError\",\r\n        \"ajaxSuccess\",\r\n        \"ajaxSend\"\r\n    ], function (i, type) {\r\n        jQuery.fn[type] = function (fn) {\r\n            return this.on(type, fn);\r\n        };\r\n    });\r\n    jQuery.expr.pseudos.animated = function (elem) {\r\n        return jQuery.grep(jQuery.timers, function (fn) {\r\n            return elem === fn.elem;\r\n        }).length;\r\n    };\r\n    /**\r\n     * Gets a window from an element\r\n     */\r\n    function getWindow(elem) {\r\n        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;\r\n    }\r\n    jQuery.offset = {\r\n        setOffset: function (elem, options, i) {\r\n            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, \"position\"), curElem = jQuery(elem), props = {};\r\n            // Set position first, in-case top/left are set even on static elem\r\n            if (position === \"static\") {\r\n                elem.style.position = \"relative\";\r\n            }\r\n            curOffset = curElem.offset();\r\n            curCSSTop = jQuery.css(elem, \"top\");\r\n            curCSSLeft = jQuery.css(elem, \"left\");\r\n            calculatePosition = (position === \"absolute\" || position === \"fixed\") &&\r\n                (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1;\r\n            // Need to be able to calculate position if either\r\n            // top or left is auto and position is either absolute or fixed\r\n            if (calculatePosition) {\r\n                curPosition = curElem.position();\r\n                curTop = curPosition.top;\r\n                curLeft = curPosition.left;\r\n            }\r\n            else {\r\n                curTop = parseFloat(curCSSTop) || 0;\r\n                curLeft = parseFloat(curCSSLeft) || 0;\r\n            }\r\n            if (jQuery.isFunction(options)) {\r\n                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\r\n                options = options.call(elem, i, jQuery.extend({}, curOffset));\r\n            }\r\n            if (options.top != null) {\r\n                props.top = (options.top - curOffset.top) + curTop;\r\n            }\r\n            if (options.left != null) {\r\n                props.left = (options.left - curOffset.left) + curLeft;\r\n            }\r\n            if (\"using\" in options) {\r\n                options.using.call(elem, props);\r\n            }\r\n            else {\r\n                curElem.css(props);\r\n            }\r\n        }\r\n    };\r\n    jQuery.fn.extend({\r\n        offset: function (options) {\r\n            // Preserve chaining for setter\r\n            if (arguments.length) {\r\n                return options === undefined ?\r\n                    this :\r\n                    this.each(function (i) {\r\n                        jQuery.offset.setOffset(this, options, i);\r\n                    });\r\n            }\r\n            var docElem, win, rect, doc, elem = this[0];\r\n            if (!elem) {\r\n                return;\r\n            }\r\n            // Support: IE <=11 only\r\n            // Running getBoundingClientRect on a\r\n            // disconnected node in IE throws an error\r\n            if (!elem.getClientRects().length) {\r\n                return { top: 0, left: 0 };\r\n            }\r\n            rect = elem.getBoundingClientRect();\r\n            // Make sure element is not hidden (display: none)\r\n            if (rect.width || rect.height) {\r\n                doc = elem.ownerDocument;\r\n                win = getWindow(doc);\r\n                docElem = doc.documentElement;\r\n                return {\r\n                    top: rect.top + win.pageYOffset - docElem.clientTop,\r\n                    left: rect.left + win.pageXOffset - docElem.clientLeft\r\n                };\r\n            }\r\n            // Return zeros for disconnected and hidden elements (gh-2310)\r\n            return rect;\r\n        },\r\n        position: function () {\r\n            if (!this[0]) {\r\n                return;\r\n            }\r\n            var offsetParent, offset, elem = this[0], parentOffset = { top: 0, left: 0 };\r\n            // Fixed elements are offset from window (parentOffset = {top:0, left: 0},\r\n            // because it is its only offset parent\r\n            if (jQuery.css(elem, \"position\") === \"fixed\") {\r\n                // Assume getBoundingClientRect is there when computed position is fixed\r\n                offset = elem.getBoundingClientRect();\r\n            }\r\n            else {\r\n                // Get *real* offsetParent\r\n                offsetParent = this.offsetParent();\r\n                // Get correct offsets\r\n                offset = this.offset();\r\n                if (!jQuery.nodeName(offsetParent[0], \"html\")) {\r\n                    parentOffset = offsetParent.offset();\r\n                }\r\n                // Add offsetParent borders\r\n                parentOffset = {\r\n                    top: parentOffset.top + jQuery.css(offsetParent[0], \"borderTopWidth\", true),\r\n                    left: parentOffset.left + jQuery.css(offsetParent[0], \"borderLeftWidth\", true)\r\n                };\r\n            }\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\r\n                left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\r\n            };\r\n        },\r\n        // This method will return documentElement in the following cases:\r\n        // 1) For the element inside the iframe without offsetParent, this method will return\r\n        //    documentElement of the parent window\r\n        // 2) For the hidden or detached element\r\n        // 3) For body or html element, i.e. in case of the html node - it will return itself\r\n        //\r\n        // but those exceptions were never presented as a real life use-cases\r\n        // and might be considered as more preferable results.\r\n        //\r\n        // This logic, however, is not guaranteed and can change at any point in the future\r\n        offsetParent: function () {\r\n            return this.map(function () {\r\n                var offsetParent = this.offsetParent;\r\n                while (offsetParent && jQuery.css(offsetParent, \"position\") === \"static\") {\r\n                    offsetParent = offsetParent.offsetParent;\r\n                }\r\n                return offsetParent || documentElement;\r\n            });\r\n        }\r\n    });\r\n    // Create scrollLeft and scrollTop methods\r\n    jQuery.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (method, prop) {\r\n        var top = \"pageYOffset\" === prop;\r\n        jQuery.fn[method] = function (val) {\r\n            return access(this, function (elem, method, val) {\r\n                var win = getWindow(elem);\r\n                if (val === undefined) {\r\n                    return win ? win[prop] : elem[method];\r\n                }\r\n                if (win) {\r\n                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\r\n                }\r\n                else {\r\n                    elem[method] = val;\r\n                }\r\n            }, method, val, arguments.length);\r\n        };\r\n    });\r\n    // Support: Safari <=7 - 9.1, Chrome <=37 - 49\r\n    // Add the top/left cssHooks using jQuery.fn.position\r\n    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\r\n    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\r\n    // getComputedStyle returns percent when specified for top/left/bottom/right;\r\n    // rather than make the css module depend on the offset module, just check for it here\r\n    jQuery.each([\"top\", \"left\"], function (i, prop) {\r\n        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\r\n            if (computed) {\r\n                computed = curCSS(elem, prop);\r\n                // If curCSS returns percentage, fallback to offset\r\n                return rnumnonpx.test(computed) ?\r\n                    jQuery(elem).position()[prop] + \"px\" :\r\n                    computed;\r\n            }\r\n        });\r\n    });\r\n    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\r\n    jQuery.each({ Height: \"height\", Width: \"width\" }, function (name, type) {\r\n        jQuery.each({ padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function (defaultExtra, funcName) {\r\n            // Margin is only for outerHeight, outerWidth\r\n            jQuery.fn[funcName] = function (margin, value) {\r\n                var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"), extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\r\n                return access(this, function (elem, type, value) {\r\n                    var doc;\r\n                    if (jQuery.isWindow(elem)) {\r\n                        // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\r\n                        return funcName.indexOf(\"outer\") === 0 ?\r\n                            elem[\"inner\" + name] :\r\n                            elem.document.documentElement[\"client\" + name];\r\n                    }\r\n                    // Get document width or height\r\n                    if (elem.nodeType === 9) {\r\n                        doc = elem.documentElement;\r\n                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\r\n                        // whichever is greatest\r\n                        return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\r\n                    }\r\n                    return value === undefined ?\r\n                        // Get width or height on the element, requesting but not forcing parseFloat\r\n                        jQuery.css(elem, type, extra) :\r\n                        // Set width or height on the element\r\n                        jQuery.style(elem, type, value, extra);\r\n                }, type, chainable ? margin : undefined, chainable);\r\n            };\r\n        });\r\n    });\r\n    jQuery.fn.extend({\r\n        bind: function (types, data, fn) {\r\n            return this.on(types, null, data, fn);\r\n        },\r\n        unbind: function (types, fn) {\r\n            return this.off(types, null, fn);\r\n        },\r\n        delegate: function (selector, types, data, fn) {\r\n            return this.on(types, selector, data, fn);\r\n        },\r\n        undelegate: function (selector, types, fn) {\r\n            // ( namespace ) or ( selector, types [, fn] )\r\n            return arguments.length === 1 ?\r\n                this.off(selector, \"**\") :\r\n                this.off(types, selector || \"**\", fn);\r\n        }\r\n    });\r\n    jQuery.parseJSON = JSON.parse;\r\n    // Register as a named AMD module, since jQuery can be concatenated with other\r\n    // files that may use define, but not via a proper concatenation script that\r\n    // understands anonymous AMD modules. A named AMD is safest and most robust\r\n    // way to register. Lowercase jquery is used because AMD module names are\r\n    // derived from file names, and jQuery is normally delivered in a lowercase\r\n    // file name. Do this after creating the global so that if an AMD module wants\r\n    // to call noConflict to hide this version of jQuery, it will work.\r\n    // Note that for maximum portability, libraries that are not jQuery should\r\n    // declare themselves as anonymous modules, and avoid setting a global if an\r\n    // AMD loader is present. jQuery is a special case. For more information, see\r\n    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"jquery\", [], function () {\r\n            return jQuery;\r\n        });\r\n    }\r\n    var \r\n    // Map over jQuery in case of overwrite\r\n    _jQuery = window.jQuery, \r\n    // Map over the $ in case of overwrite\r\n    _$ = window.$;\r\n    jQuery.noConflict = function (deep) {\r\n        if (window.$ === jQuery) {\r\n            window.$ = _$;\r\n        }\r\n        if (deep && window.jQuery === jQuery) {\r\n            window.jQuery = _jQuery;\r\n        }\r\n        return jQuery;\r\n    };\r\n    // Expose jQuery and $ identifiers, even in AMD\r\n    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\r\n    // and CommonJS for browser emulators (#13566)\r\n    if (!noGlobal) {\r\n        window.jQuery = window.$ = jQuery;\r\n    }\r\n    return jQuery;\r\n});\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var visuals;\r\n    (function (visuals) {\r\n        var plugins;\r\n        (function (plugins) {\r\n            plugins.PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6_DEBUG = {\r\n                name: 'PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6_DEBUG',\r\n                displayName: 'viz02',\r\n                class: 'Visual',\r\n                version: '1.0.0',\r\n                apiVersion: '1.5.0',\r\n                create: function (options) { return new powerbi.extensibility.visual.PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6.Visual(options); },\r\n                custom: true\r\n            };\r\n        })(plugins = visuals.plugins || (visuals.plugins = {}));\r\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\r\n})(powerbi || (powerbi = {}));\r\n//# sourceMappingURL=visual.js.map","css":".visual-PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6_DEBUG #myTable {\n  background-color: black;\n  font-size: 32px;\n}\n.visual-PBI_CV_1F297329_EBD9_43ED_9E6C_798DF0E8D6A6_DEBUG #myTable td {\n  background-color: lightyellow;\n  color: darkblue;\n  padding: 12px;\n}\n","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2RpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpBOEJGMzkxN0NBRDNFMDExQTcxQ0JFODI3ODBCQUE5RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3NEY1QjA1NUQ0OTAxMUUwQTgxREI2NjMxMkNEMUNEMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3NEY1QjA1NEQ0OTAxMUUwQTgxREI2NjMxMkNEMUNEMyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5Mjk5RDU1ODBGRDRFMDExQTcxQ0JFODI3ODBCQUE5RSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBOEJGMzkxN0NBRDNFMDExQTcxQ0JFODI3ODBCQUE5RSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpDoNX0AAAI3SURBVHjarJRLSFVRFIY9t7SiRDGLoEEPCRJRaCSYkxCiFCXCF+LIMExQLkilgumgwkbdBuWDRC2EomhURCOjgagkXEgKLUKhidobM6H0+i34rxyPnuvEA5/rXPda/1l7739vJxKJxG3ls93+hEKhTILxJhgMftmsiPxdhHw4CfepeR8dCyjWwwB0kZy3iVgCoQ2ewnmXxhrBD7Cgr/ZQVA17fDRPw2UYhzK6G99IsBse6/0QNME+H8FT4EA/YiPqOgA1q4IMzBNuw6iKjkCpj+Av+AdnEEmD3bxfhzvuDk30HaEaLsEkXCO53rN+Bwg5qsvTuj/TjGYtx9nINhRmEx7AYWiFW7AXOuEcbPOUvIZ2mnrl+PkQUbNEh4QHNKUSDdsSBWEOlmxTEfvs26FL9Khe211if6Acgee+xo7xzMgBxfq9qPe3fgWBGN2lEnqtG9nExM7CV3jp3bDos2bKJB0nHFRxAxRpA/5CIXyHh5ABv6GZqd9dJ6iz2SjbxMMypGhJFtTlNzu3kK7xgDxpove8U66FK2A+s6nul5gVVMEL+Ak7lG/T+g9JcIOGar2CRUoogxMwpP/bLTJMB9bRhDbkk5bBUU0y3ES0xS04CBfN9RSHiY90vJK0BHaSzG9h2eejS3RJeVfdtrGzuGyd8CX7Yq6ExuCH63jaVMPkFOv6OibB6DKs2+VEQp+WYBoqERn2sVWWRNN0YurIfeL14U6YkpkLYCSG6e0yqdCxvKBLIm5FgAEAV0nKuwMYRUsAAAAASUVORK5CYII="}}